# 1. Your First Component
React는 **컴포넌트**라고 불리는 분리된 UI 조각으로 구축된다.  
컴포넌트는 React의 핵심 개념 중 하나로써, 사용자 인터페이스(UI)를 구축하는 기반이다.  
컴포넌트는 마크업(태그 등을 이용하여 문서나 데이터의 구조를 명기하는 것)으로 뿌릴 수 있는 JavaScript 함수이다.  
컴포넌트는 버튼처럼 작을 수도 있고 전체 페이지처럼 클 수도 있다.  
<br>
  
## Components: UI building blocks (컴포넌트 : UI 구성 요소)
웹은 HTML을 통해 여러가지 태그를 사용하여 다양한 내용을 구성할 수 있다.  
React를 사용하면 마크업, CSS, JavaScript를 **앱의 재사용 가능한 UI 요소**인 사용자 정의 “컴포넌트”로 결합할 수 있다.  
HTML 태그와 마찬가지로 컴포넌트를 작성, 순서 지정 및 중첩하여 전체 페이지를 디자인할 수 있다.  
반복해서 사용하는 태그를 모아 컴포넌트로 구성한다면 재사용함으로써 개발 속도를 줄일 수 있다.  
<br>
  
## Defining a component (컴포넌트 정의하기)
기존에는 웹 페이지를 만들 때 웹 개발자가 콘텐츠를 마크업한 다음 JavaScript를 뿌려 상호작용을 추가했다.  
React는 동일한 기술을 사용하면서도 상호작용을 우선시한다.  
React 컴포넌트는 마크업으로 뿌릴 수 있는 JavaScript 함수이다.  

### STEP 1 : Export the component (컴포넌트 내보내기)
```export default``` 접두사는 표준 JavaScript 구문이다(React에만 해당되지 않음).  
나중에 다른 파일에서 가져올 수 있도록 파일에 주요 기능을 표시한다.  

### STEP 2: Define the function (함수 정의하기)
```function Person () {}```을 통해 Person이라는 이름의 컴포넌트를 만들 수 있음.  
React 컴포넌트는 일반 JavaScript 함수이지만, 이름은 대문자로 시작하는 것을 권장한다.  
> React 컴포넌트는 항상 대문자로 시작해야 하지만, 함수명이 대문자일 필요는 없다.  
> 그러나 **JSX 안에서 컴포넌트가 사용될 때에는 반드시 대문자로 시작**해야 한다.  
> ```default export```의 경우  
> - import시에 대문자로 시작하는 새로운 이름을 부여
> 
> ```named export```의 경우  
> 1. import시에 as로 대문자로 시작하는 새로운 이름을 부여
> 2. 컴포넌트 외부에서 대문자로 시작하는 새로운 변수에 할당
> 3. 컴포넌트 내부에서 대문자로 시작하는 새로운 변수에 할당
>
> < 예시 >
> ```javascript
> // app.js
> import DefaultPerson from "./DefaultPerson";
> import {
>   NamedExportedOne,
>   namedExportedTwo as NamedTwo,
>   namedExportedThree
> } from "./Persons";
>
> const NamedThree = namedExportedThree;
> ```
> ```javascript
> // DefaultPerson.js
> export default function exportedDefault({ user }) { };
> ```
> ```javascript
> //  Persons
> export function NamedExportedOne({ user }) { };
> export function namedExportedTwo({ user }) { };
> export function namedExportedThree({ user }) { };
> ```

### STEP 3 : Add markup (마크업 추가하기)
REACT 컴포넌트의 return문에는 HTML과 비슷하지만 다른 jsx 구문을 반환한다.  
jsx 구분을 통해 마크을 삽입할 수 있다.  
**return문은 한 줄로 모두 작성할 수 있고, 여러 줄인 경우 소괄호 필수**  
소괄호 없이 다음 줄에 작성한다면 뒷 라인 코드는 모두 무시된다.  
```javascript
// return문이 한 줄일 때
return <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />;
// return문이 여러 줄일 때
return (
  <div>
    <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />
  </div>
);
```
<br>

## Using a component (컴포넌트 사용하기)
컴포넌트는 다른 컴포넌트와 중첩하여 사용할 수 있다.  
컴포넌트가 상대적으로 작거나 서로 밀접하게 관련되어 있을 때 편리하다.  
파일이 복잡하다면 언제든지 분리해서 사용할 수 있다.  
컴포넌트는 다른 컴포넌트를 렌더링할 수 있지만, 그 **정의를 중첩해서는 안 된다.**
자식 컴포넌트에 부모 컴포넌트의 일부 데이터가 필요한 경우, 정의를 중첩하는 대신 props로 전달해야 한다.  
<br>

## Your First Component Recap (첫번째 컴포넌트 요약)
- React를 사용하면 앱의 재사용 가능한 UI 요소인 컴포넌트를 만들 수 있다.
- React 앱에서 모든 UI는 컴포넌트이다. 
- React 컴포넌트는 다음 몇 가지를 제외하고는 일반적인 JavaScript 함수이다.
  1. 컴포넌트의 이름은 항상 대문자로 시작한다.
  2. JSX 마크업을 반환한다.
<br>

## Your First Component Try out some challenges (첫번째 컴포넌트 도전과제)
### Q1. Export the component
문제 : This sandbox doesn’t work because the root component is not exported
```javascript
// App.js
function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}
```
해결 : Profile 함수를 export 해준다.
```javascript
export default function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}
```

### Q2. Fix the return statement
문제 : Something isn’t right about this return statement. Can you fix it?
```javascript
export default function Profile() {
  return
    <img src="https://i.imgur.com/jA8hHMpm.jpg" alt="Katsuko Saruhashi" />;
}
```
해결 : return 바로 다음에 한 줄로 작성하도록 한다. 아니면 소괄호 사용!
```javascript
export default function Profile() {
  return <img src="https://i.imgur.com/jA8hHMpm.jpg" alt="Katsuko Saruhashi" />;
}
```

### Q3. Spot the mistake
문제 : Something’s wrong with how the Profile component is declared and used. Can you spot the mistake?   
      (Try to remember how React distinguishes components from the regular HTML tags!)
```javascript
function profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <profile />
      <profile />
      <profile />
    </section>
  );
}
```
해결 : 컴포넌트는 대문자로 시작해야 한다. 선언부부터 불러서 사용하는 부분까지 다 대분자로 시작하도록 수정한다.
```javascript
function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

### Q4. Your own component
문제 : Write a component from scratch. You can give it any valid name and return any markup.   
      If you’re out of ideas, you can write a Congratulations component that shows ```<h1>Good job!</h1>```. Don’t forget to export it!  
해결 : 
```javascript
export default function Congratulations() {
  return <h1>Good job!</h1>
}
```
<br>
  
  
# 2. Importing and Exporting Components
하나의 파일에 여러 컴포넌트를 선언할 수 있지만 파일이 크면 탐색하기 어려울 수 있다. 이 문제를 import, export로 해결하자.  
컴포넌트의 가장 큰 장점은 재사용성으로 컴포넌트를 조합해 또 다른 컴포넌트를 만들 수 있다는 것이다.  
컴포넌트를 여러 번 중첩하게 되면 다른 파일로 분리해야 하는 시점이 생기는데, 이렇게 분리하면 나중에 파일을 찾기 더 쉽고 재사용하기 편리하다.  
~많이 나눌수록 찾기 힘들던데..~
<br>
  
## The root component file (루트 컴포넌트 파일)
```Create React App``을 사용한 앱 전체가 src/App.js에서 실행된다. 이 때, App.js가 **루트 컴포넌트 파일**이다.  
설정에 따라 root 컴포넌트가 다른 파일에 위치할 수도 있다.  
Next.js처럼 파일 기반으로 라우팅하는 프레임워크일 경우 페이지별로 root 컴포넌트가 다를 수 있다.  
<br>

## Exporting and importing a component (컴포넌트 export 및 import)
대부분의 경우 컴포넌트는 한 파일에 하나만 있도록 개발한다.  
모듈성이 강화되고 다른 파일에서 재사용할 수 있도록 하기 위함이다.  
컴포넌트는 다음의 3단계를 거쳐 import, export를 한다.  
1. 컴포넌트를 넣을 js 생성 (컴포넌트의 return에는 jsx 문법이 들어가므로 jsx 확장자 사용 권장)
2. 새로 만든 파일에서 함수 컴포넌트를 export (default 또는 named export 방식을 사용)
3. 컴포넌트를 사용할 파일에서 import (default 또는 named export에 대응하는 방식으로 import)

> ## Default vs named exports
> JavaScript에서는 default export와 named export라는 두 가지 방법으로 값을 export한다. 두 방법 다 한 파일에서 사용할 수도 있다.  
> 단, **한 파일에서는 하나의 default export만 존재할 수 있고 named export는 여러 개가 존재할 수 있다.**
> |Syntax|Export statement|Import statement|
> |---|---|---|
> |Default|```export default function Button() {}```|```import Button from './Button.js';```|
> |Named|```export function Button() {}```|```import { Button } from './Button.js';```|
>   
> 이때, default 는 하나밖에 없으므로 import 해올 때 다른 이름으로 불러올 수 있다.  
> 예를 들어, 위의 경우에서 Button이 아니라 ```import Push from './Button.js'```처럼 이름을 바꿀 수 있다.  
> named를 사용할 때는 똑같은 이름을 사용해 불러와야 한다.  
> 보편적으로 한 파일에서 하나의 컴포넌트만 export 할 때 default export 방식을 사용하고 여러 컴포넌트를 export 할 경우엔 named export 방식을 사용한다.  
> default export와 named export 사이의 혼동의 가능성을 줄이기 위해 일부 팀에서는 한 가지 스타일(default 또는 named)만 고수하거나, 단일 파일 내에서 혼합하지 않도록 선택한다.
> 선택은 자신의 몫!
> <br>

> ## 한 파일에 여러 컴포넌트를 넣는 경우
> 앞서 말했듯이 컴포넌트는 한 파일에 하나만 사용하는 것을 권장한다.
> 하지만 예외적인 상황이 2가지 있다.
> 1. 오직 하나의 컴포넌트에서만 사용할 가능성이 99% 이상인 경우
> 2. 하나씩 묶음으로 처리하는 것이 더 좋을 경우 (ex. Modal.header, Modal.footer)
<br>
  
## Importing and Exporting Components Try out some challenges (컴포넌트 import 및 export 도전 과제)
### Q1. Split the components further
문제 :  
Currently, Gallery.js exports both Profile and Gallery, which is a bit confusing.  
Move the Profile component to its own Profile.js, and then change the App component to render both ```<Profile />``` and ```<Gallery />``` one after another.  
You may use either a default or a named export for Profile, but make sure that you use the corresponding import syntax in both App.js and Gallery.js!  
```javascript
// App.js
import Gallery from './Gallery.js';
import { Profile } from './Gallery.js';

export default function App() {
  return (
    <div>
      <Profile />
    </div>
  );
}
```
```javascript
// Gallery.js
// Move me to Profile.js!
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```
해결 :  
Profile.js 에 Profile 컴포넌트를 옮기고 export해준다.  
App.js 에서도 Gallery.js에서도 Profile을 사용하므로 두 파일에서 모두 import 한다.  
```javascript
// App.js
import Gallery from './Gallery.js';
import { Profile } from './Profile.js';

export default function App() {
  return (
    <div>
      <Gallery />
      <Profile />
    </div>
  );
}
```
```javascript
// Gallery.js
import { Profile } from './Profile.js'

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```
```javascript
// Profile.js
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}
```
<br>


# 3. Writing Markup with JSX
React 컴포넌트는 JSX라는 구문 확장자를 사용해 마크업을 표현하고, JSX는 HTML과 매우 비슷해 보이지만 조금 더 엄격하고 동적 정보를 표시한다.  
JSX는 JavaScript를 확장한 문법으로, JavaScript 파일 안에 HTML과 유사한 마크업을 작성할 수 있도록 한다.  
컴포넌트를 작성하는 다른 방법도 있지만, 대부분의 React개발자는 JSX의 간결함을 선호하며 대부분의 코드베이스에서 JSX를 사용한다.  
<br>

## JSX: Putting markup into JavaScript (JSX : JS에 markup 넣기)
기존에 웹은 HTML로 컨텐츠를, CSS로 디자인을, 로직은 JavaScript로 작성하면서 따로 분리하여 파일을 관리했다.  
하지만 웹이 더욱 interactive 해지면서 로직이 컨텐츠를 결정하는 경우가 많아졌기 때문에 JavaScript가 HTML을 담당하게 되었다.  
이것이 React에서 렌더링 로직과 마크업이 같은 위치의 컴포넌트에 함께 있는 이유이다.  

각 React 컴포넌트는 React가 브라우저에 마크업을 렌더링할 수 있는 JavaScript 함수이다.  
React 컴포넌트는 JSX라는 구문 확장자를 사용하여 해당되는 마크업을 표현한다.  

> JSX와 React는 서로 다른 별개의 개념  
> 종종 함께 사용되기도 하지만 독립적으로 사용할 수도 있다.  
> JSX는 구문 확장이고, React는 JavaScript 라이브러리입니다.
<br>
  
## The Rules of JSX (JSX의 규칙)
1. **단일 루트 엘리먼트를 반환해라.**  
  컴포넌트에서 여러 엘리먼트를 반환하려면, **하나의 부모 태그로 감싸야 한다.**
  하나의 부모 태그로 감쌀 때 ```<div>``` 태그를 사용해도 되지만, ```<> </>``` 이렇게 빈 태그를 사용할 수 있다.  
  빈 태그는 *Fragment*라고 하고, 브라우저상의 HTML 트리 구조에서 흔적을 남기지 않고 그룹화해준다.

  > ### Why 여러 JSX태그를 하나로 감싸줘야 할까?
  > JSX는 HTML처럼 보이지만 내부적으로는 JavaScript 객체로 변환된다.  
  > 하나의 배열로 감싸지 않은 하나의 함수에서는 두 개의 객체를 반환할 수 없다.  
  > 따라서 또 다른 태그나 Fragment로 감싸지 않으면 두 개의 JSX태그를 반환할 수 없다.

2. **모든 태그를 닫아라.**
3. **대부분이 카멜 케이스**  
   JSX는 JS 바뀌고 JSX로 작성된 어트리뷰트는 JS 객체의 키가 된다.  
   JS 변수명에는 제한이 있기 때문에 (예. 변수명에 대쉬(-) 불가, 예약어 사용 불가 등) 태그의 속성들이 대부분 카멜 케이스를 따른다.  

> aria-* and data-* 속성은 동일하게 대쉬를 적용한다.  
> 두 개의 속성에 대해 공부하자!
<br>

## Writing Markup with JSX Recap (JSX로 마크업 작성하기 요약)
- React 컴포넌트는 서로 관련이 있는 마크업과 렌더링 로직을 함께 그룹화한다.
- JSX는 HTML과 비슷하지만 몇 가지 차이점이 있다. 필요한 경우 변환기를 사용할 수 있다.
- 오류 메세지는 종종 마크업을 수정할 수 있도록 올바른 방향을 알려준다.
<br>

## Writing Markup with JSX Try out some challenges (JSX로 마크업 작성하기 도전과제)
### Q1. Convert some HTML to JSX
문제 : 
This HTML was pasted into a component, but it’s not valid JSX. Fix it:
```javascript
// App.js
export default function Bio() {
  return (
    <div class="intro">
      <h1>Welcome to my website!</h1>
    </div>
    <p class="summary">
      You can find my thoughts here.
      <br><br>
      <b>And <i>pictures</b></i> of scientists!
    </p>
  );
}
```
해결 :
1. 반환되는 jsx 구문은 하나의 태그로 묶어야 한다.
2. br 태그를 닫아야 한다.
3. i태그가 b태그 안에 있으므로 b태그 닫는 구문을 i태그 닫는 구문보다 뒤에 둬야 한다.
```javascript
// App.js
export default function Bio() {
  return (
    <>
      <div class="intro">
        <h1>Welcome to my website!</h1>
      </div>
      <p class="summary">
        You can find my thoughts here.
        <br/><br/>
        <b>And <i>pictures</i></b> of scientists!
      </p>
    </>
  );
}
```
<br>


# 4. JavaScript in JSX with Curly Braces
