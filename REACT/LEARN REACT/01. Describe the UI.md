# 1. Your First Component
React는 **컴포넌트**라고 불리는 분리된 UI 조각으로 구축된다.  
컴포넌트는 React의 핵심 개념 중 하나로써, 사용자 인터페이스(UI)를 구축하는 기반이다.  
React를 사용하면 재사용 가능하고 중첩 가능한 컴포넌트로 결합할 수 있다.  
컴포넌트는 마크업(태그 등을 이용하여 문서나 데이터의 구조를 명기하는 것)으로 뿌릴 수 있는 JavaScript 함수이다.  
컴포넌트는 버튼처럼 작을 수도 있고 전체 페이지처럼 클 수도 있다.  
<br>
  
## Components: UI building blocks (컴포넌트 : UI 구성 요소)
웹은 HTML을 통해 여러가지 태그를 사용하여 다양한 내용을 구성할 수 있다.  
React를 사용하면 마크업, CSS, JavaScript를 **앱의 재사용 가능한 UI 요소**인 사용자 정의 “컴포넌트”로 결합할 수 있다.  
HTML 태그와 마찬가지로 컴포넌트를 작성, 순서 지정 및 중첩하여 전체 페이지를 디자인할 수 있다.  
반복해서 사용하는 태그를 모아 컴포넌트로 구성한다면 재사용함으로써 개발 속도를 줄일 수 있다.  
<br>
  
## Defining a component (컴포넌트 정의하기)
기존에는 웹 페이지를 만들 때 웹 개발자가 콘텐츠를 마크업한 다음 JavaScript를 뿌려 상호작용을 추가했다.  
React는 동일한 기술을 사용하면서도 상호작용을 우선시한다.  
React 컴포넌트는 마크업으로 뿌릴 수 있는 JavaScript 함수이다.  

### STEP 1 : Export the component (컴포넌트 내보내기)
```export default``` 접두사는 표준 JavaScript 구문이다(React에만 해당되지 않음).  
나중에 다른 파일에서 가져올 수 있도록 파일에 주요 기능을 표시한다.  

### STEP 2: Define the function (함수 정의하기)
```function Person () {}```을 통해 Person이라는 이름의 컴포넌트를 만들 수 있음.  
React 컴포넌트는 일반 JavaScript 함수이지만, 이름은 대문자로 시작하는 것을 권장한다.  
> React 컴포넌트는 항상 대문자로 시작해야 하지만, 함수명이 대문자일 필요는 없다.  
> 그러나 **JSX 안에서 컴포넌트가 사용될 때에는 반드시 대문자로 시작**해야 한다.  
> ```default export```의 경우  
> - import시에 대문자로 시작하는 새로운 이름을 부여
> 
> ```named export```의 경우  
> 1. import시에 as로 대문자로 시작하는 새로운 이름을 부여
> 2. 컴포넌트 외부에서 대문자로 시작하는 새로운 변수에 할당
> 3. 컴포넌트 내부에서 대문자로 시작하는 새로운 변수에 할당
>
> < 예시 >
> ```javascript
> // app.js
> import DefaultPerson from "./DefaultPerson";
> import {
>   NamedExportedOne,
>   namedExportedTwo as NamedTwo,
>   namedExportedThree
> } from "./Persons";
>
> const NamedThree = namedExportedThree;
> ```
> ```javascript
> // DefaultPerson.js
> export default function exportedDefault({ user }) { };
> ```
> ```javascript
> //  Persons
> export function NamedExportedOne({ user }) { };
> export function namedExportedTwo({ user }) { };
> export function namedExportedThree({ user }) { };
> ```

### STEP 3 : Add markup (마크업 추가하기)
REACT 컴포넌트의 return문에는 HTML과 비슷하지만 다른 jsx 구문을 반환한다.  
jsx 구분을 통해 마크을 삽입할 수 있다.  
**return문은 한 줄로 모두 작성할 수 있고, 여러 줄인 경우 소괄호 필수**  
소괄호 없이 다음 줄에 작성한다면 뒷 라인 코드는 모두 무시된다.  
```javascript
// return문이 한 줄일 때
return <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />;
// return문이 여러 줄일 때
return (
  <div>
    <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />
  </div>
);
```
<br>

## Using a component (컴포넌트 사용하기)
컴포넌트는 다른 컴포넌트와 중첩하여 사용할 수 있다.  
컴포넌트가 상대적으로 작거나 서로 밀접하게 관련되어 있을 때 편리하다.  
파일이 복잡하다면 언제든지 분리해서 사용할 수 있다.  
컴포넌트는 다른 컴포넌트를 렌더링할 수 있지만, 그 **정의를 중첩해서는 안 된다.**
자식 컴포넌트에 부모 컴포넌트의 일부 데이터가 필요한 경우, 정의를 중첩하는 대신 props로 전달해야 한다.  
<br>

## Your First Component Recap (첫번째 컴포넌트 요약)
- React를 사용하면 앱의 재사용 가능한 UI 요소인 컴포넌트를 만들 수 있다.
- React 앱에서 모든 UI는 컴포넌트이다. 
- React 컴포넌트는 다음 몇 가지를 제외하고는 일반적인 JavaScript 함수이다.
  1. 컴포넌트의 이름은 항상 대문자로 시작한다.
  2. JSX 마크업을 반환한다.
<br>

## Your First Component Try out some challenges (첫번째 컴포넌트 도전과제)
### Q1. Export the component
문제 : This sandbox doesn’t work because the root component is not exported
```javascript
// App.js
function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}
```
해결 : Profile 함수를 export 해준다.
```javascript
export default function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}
```

### Q2. Fix the return statement
문제 : Something isn’t right about this return statement. Can you fix it?
```javascript
export default function Profile() {
  return
    <img src="https://i.imgur.com/jA8hHMpm.jpg" alt="Katsuko Saruhashi" />;
}
```
해결 : return 바로 다음에 한 줄로 작성하도록 한다. 아니면 소괄호 사용!
```javascript
export default function Profile() {
  return <img src="https://i.imgur.com/jA8hHMpm.jpg" alt="Katsuko Saruhashi" />;
}
```

### Q3. Spot the mistake
문제 : Something’s wrong with how the Profile component is declared and used. Can you spot the mistake?   
      (Try to remember how React distinguishes components from the regular HTML tags!)
```javascript
function profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <profile />
      <profile />
      <profile />
    </section>
  );
}
```
해결 : 컴포넌트는 대문자로 시작해야 한다. 선언부부터 불러서 사용하는 부분까지 다 대분자로 시작하도록 수정한다.
```javascript
function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

### Q4. Your own component
문제 : Write a component from scratch. You can give it any valid name and return any markup.   
      If you’re out of ideas, you can write a Congratulations component that shows ```<h1>Good job!</h1>```. Don’t forget to export it!  
해결 : 
```javascript
export default function Congratulations() {
  return <h1>Good job!</h1>
}
```
<br>
  
  
# 2. Importing and Exporting Components
하나의 파일에 여러 컴포넌트를 선언할 수 있지만 파일이 크면 탐색하기 어려울 수 있다. 이 문제를 import, export로 해결하자.  
컴포넌트의 가장 큰 장점은 재사용성으로 컴포넌트를 조합해 또 다른 컴포넌트를 만들 수 있다는 것이다.  
컴포넌트를 여러 번 중첩하게 되면 다른 파일로 분리해야 하는 시점이 생기는데, 이렇게 분리하면 나중에 파일을 찾기 더 쉽고 재사용하기 편리하다.  
~많이 나눌수록 찾기 힘들던데..~
<br>
  
## The root component file (루트 컴포넌트 파일)
```Create React App``을 사용한 앱 전체가 src/App.js에서 실행된다. 이 때, App.js가 **루트 컴포넌트 파일**이다.  
설정에 따라 root 컴포넌트가 다른 파일에 위치할 수도 있다.  
Next.js처럼 파일 기반으로 라우팅하는 프레임워크일 경우 페이지별로 root 컴포넌트가 다를 수 있다.  
<br>

## Exporting and importing a component (컴포넌트 export 및 import)
대부분의 경우 컴포넌트는 한 파일에 하나만 있도록 개발한다.  
모듈성이 강화되고 다른 파일에서 재사용할 수 있도록 하기 위함이다.  
컴포넌트는 다음의 3단계를 거쳐 import, export를 한다.  
1. 컴포넌트를 넣을 js 생성 (컴포넌트의 return에는 jsx 문법이 들어가므로 jsx 확장자 사용 권장)
2. 새로 만든 파일에서 함수 컴포넌트를 export (default 또는 named export 방식을 사용)
3. 컴포넌트를 사용할 파일에서 import (default 또는 named export에 대응하는 방식으로 import)

> ## Default vs named exports
> JavaScript에서는 default export와 named export라는 두 가지 방법으로 값을 export한다. 두 방법 다 한 파일에서 사용할 수도 있다.  
> 단, **한 파일에서는 하나의 default export만 존재할 수 있고 named export는 여러 개가 존재할 수 있다.**
> |Syntax|Export statement|Import statement|
> |---|---|---|
> |Default|```export default function Button() {}```|```import Button from './Button.js';```|
> |Named|```export function Button() {}```|```import { Button } from './Button.js';```|
>   
> 이때, default 는 하나밖에 없으므로 import 해올 때 다른 이름으로 불러올 수 있다.  
> 예를 들어, 위의 경우에서 Button이 아니라 ```import Push from './Button.js'```처럼 이름을 바꿀 수 있다.  
> named를 사용할 때는 똑같은 이름을 사용해 불러와야 한다.  
> 보편적으로 한 파일에서 하나의 컴포넌트만 export 할 때 default export 방식을 사용하고 여러 컴포넌트를 export 할 경우엔 named export 방식을 사용한다.  
> default export와 named export 사이의 혼동의 가능성을 줄이기 위해 일부 팀에서는 한 가지 스타일(default 또는 named)만 고수하거나, 단일 파일 내에서 혼합하지 않도록 선택한다.
> 선택은 자신의 몫!
> <br>

> ## 한 파일에 여러 컴포넌트를 넣는 경우
> 앞서 말했듯이 컴포넌트는 한 파일에 하나만 사용하는 것을 권장한다.
> 하지만 예외적인 상황이 2가지 있다.
> 1. 오직 하나의 컴포넌트에서만 사용할 가능성이 99% 이상인 경우
> 2. 하나씩 묶음으로 처리하는 것이 더 좋을 경우 (ex. Modal.header, Modal.footer)
<br>
  
## Importing and Exporting Components Try out some challenges (컴포넌트 import 및 export 도전 과제)
### Q1. Split the components further
문제 :  
Currently, Gallery.js exports both Profile and Gallery, which is a bit confusing.  
Move the Profile component to its own Profile.js, and then change the App component to render both ```<Profile />``` and ```<Gallery />``` one after another.  
You may use either a default or a named export for Profile, but make sure that you use the corresponding import syntax in both App.js and Gallery.js!  
```javascript
// App.js
import Gallery from './Gallery.js';
import { Profile } from './Gallery.js';

export default function App() {
  return (
    <div>
      <Profile />
    </div>
  );
}
```
```javascript
// Gallery.js
// Move me to Profile.js!
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```
해결 :  
Profile.js 에 Profile 컴포넌트를 옮기고 export해준다.  
App.js 에서도 Gallery.js에서도 Profile을 사용하므로 두 파일에서 모두 import 한다.  
```javascript
// App.js
import Gallery from './Gallery.js';
import { Profile } from './Profile.js';

export default function App() {
  return (
    <div>
      <Gallery />
      <Profile />
    </div>
  );
}
```
```javascript
// Gallery.js
import { Profile } from './Profile.js'

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```
```javascript
// Profile.js
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}
```
<br>


# 3. Writing Markup with JSX
React 컴포넌트는 JSX라는 구문 확장자를 사용해 마크업을 표현하고, JSX는 HTML과 매우 비슷해 보이지만 조금 더 엄격하고 동적 정보를 표시한다.  
JSX는 JavaScript를 확장한 문법으로, JavaScript 파일 안에 HTML과 유사한 마크업을 작성할 수 있도록 한다.  
컴포넌트를 작성하는 다른 방법도 있지만, 대부분의 React개발자는 JSX의 간결함을 선호하며 대부분의 코드베이스에서 JSX를 사용한다.  
<br>

## JSX: Putting markup into JavaScript (JSX : JS에 markup 넣기)
기존에 웹은 HTML로 컨텐츠를, CSS로 디자인을, 로직은 JavaScript로 작성하면서 따로 분리하여 파일을 관리했다.  
하지만 웹이 더욱 interactive 해지면서 로직이 컨텐츠를 결정하는 경우가 많아졌기 때문에 JavaScript가 HTML을 담당하게 되었다.  
이것이 React에서 렌더링 로직과 마크업이 같은 위치의 컴포넌트에 함께 있는 이유이다.  

각 React 컴포넌트는 React가 브라우저에 마크업을 렌더링할 수 있는 JavaScript 함수이다.  
React 컴포넌트는 JSX라는 구문 확장자를 사용하여 해당되는 마크업을 표현한다.  

> JSX와 React는 서로 다른 별개의 개념  
> 종종 함께 사용되기도 하지만 독립적으로 사용할 수도 있다.  
> JSX는 구문 확장이고, React는 JavaScript 라이브러리입니다.
<br>
  
## The Rules of JSX (JSX의 규칙)
1. **단일 루트 엘리먼트를 반환해라.**  
  컴포넌트에서 여러 엘리먼트를 반환하려면, **하나의 부모 태그로 감싸야 한다.**
  하나의 부모 태그로 감쌀 때 ```<div>``` 태그를 사용해도 되지만, ```<> </>``` 이렇게 빈 태그를 사용할 수 있다.  
  빈 태그는 *Fragment*라고 하고, 브라우저상의 HTML 트리 구조에서 흔적을 남기지 않고 그룹화해준다.

  > ### Why 여러 JSX태그를 하나로 감싸줘야 할까?
  > JSX는 HTML처럼 보이지만 내부적으로는 JavaScript 객체로 변환된다.  
  > 하나의 배열로 감싸지 않은 하나의 함수에서는 두 개의 객체를 반환할 수 없다.  
  > 따라서 또 다른 태그나 Fragment로 감싸지 않으면 두 개의 JSX태그를 반환할 수 없다.

2. **모든 태그를 닫아라.**
3. **대부분이 카멜 케이스**  
   JSX는 JS 바뀌고 JSX로 작성된 어트리뷰트는 JS 객체의 키가 된다.  
   JS 변수명에는 제한이 있기 때문에 (예. 변수명에 대쉬(-) 불가, 예약어 사용 불가 등) 태그의 속성들이 대부분 카멜 케이스를 따른다.  

> aria-* and data-* 속성은 동일하게 대쉬를 적용한다.  
> 두 개의 속성에 대해 공부하자!
<br>

## Writing Markup with JSX Recap (JSX로 마크업 작성하기 요약)
- React 컴포넌트는 서로 관련이 있는 마크업과 렌더링 로직을 함께 그룹화한다.
- JSX는 HTML과 비슷하지만 몇 가지 차이점이 있다. 필요한 경우 변환기를 사용할 수 있다.
- 오류 메세지는 종종 마크업을 수정할 수 있도록 올바른 방향을 알려준다.
<br>

## Writing Markup with JSX Try out some challenges (JSX로 마크업 작성하기 도전과제)
### Q1. Convert some HTML to JSX
문제 : 
This HTML was pasted into a component, but it’s not valid JSX. Fix it:
```javascript
// App.js
export default function Bio() {
  return (
    <div class="intro">
      <h1>Welcome to my website!</h1>
    </div>
    <p class="summary">
      You can find my thoughts here.
      <br><br>
      <b>And <i>pictures</b></i> of scientists!
    </p>
  );
}
```
해결 :
1. 반환되는 jsx 구문은 하나의 태그로 묶어야 한다.
2. br 태그를 닫아야 한다.
3. i태그가 b태그 안에 있으므로 b태그 닫는 구문을 i태그 닫는 구문보다 뒤에 둬야 한다.
```javascript
// App.js
export default function Bio() {
  return (
    <>
      <div class="intro">
        <h1>Welcome to my website!</h1>
      </div>
      <p class="summary">
        You can find my thoughts here.
        <br/><br/>
        <b>And <i>pictures</i></b> of scientists!
      </p>
    </>
  );
}
```
<br>


# 4. JavaScript in JSX with Curly Braces
JSX를 사용하면 JavaScript 파일 내에 HTML과 유사한 마크업을 작성하여 렌더링 로직과 콘텐츠를 같은 위치에 유지할 수 있다.  
마크업 안에 약간의 JavaScript 로직을 추가하거나 동적 프로퍼티를 참조하고 싶을 때가 있다면, JSX에서 *중괄호*를 사용하여 JavaScript로의 ‘창을 열’어보자!   

## Passing strings with quotes (따옴표를 문자열 전달하기)
JSX에 문자열 속성을 전달하려면, 작은따옴표 또는 큰따옴표로 묶는다.  
아래의 예시처럼 지정된 값만 넣으려면 따옴표 ' ', " "를 사용한다.  
```javascript
export default function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/7vQD0fPs.jpg"
      alt="Gregorio Y. Zara"
    />
  );
}
```

하지만, 동적인 값을 넣고 싶다면 중괄호 { } 를 사용한다.  
중괄호를 사용하여 JS의 변수를 바로 삽입할 수 있다.  
```javascript
export default function Avatar() {
  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';
  const description = 'Gregorio Y. Zara';
  return (
    <img
      className="avatar"
      src={avatar}
      alt={description}
    />
  );
}
```
<br>

## Using curly braces: A window into the JavaScript world (중괄호 사용하기: JS 세계를 들여다보는 창)
JSX는 JS를 작성하는 특별한 방법이다. 즉, 중괄호를 사용하여 JSX안에 JS를 사용할 수 있다는 것이다.  
단순히 변수뿐만 아니라 함수를 삽입할 수도 있다.  
```javascript
const today = new Date();

function formatDate(date) {
  return new Intl.DateTimeFormat(
    'en-US',
    { weekday: 'long' }
  ).format(date);
}

export default function TodoList() {
  return (
    <h1>To Do List for {formatDate(today)}</h1>
  );
}
```

### Where to use curly braces (중괄호 사용 위치)
JSX에서는 중괄호를 딱 2가지 경우에만 사용  
1. JSX 태그 안에 직접 텍스트로 사용  
   <```h1>{name}'s To Do List</h1>``` 는 작동하지만 ```<{tag}>Gregorio Y. Zara's To Do List</{tag}>``` 는 작동하지 않는다.
   이때, 컴포넌트를 태그처럼 사용하는 것은 가능하다. ```fucntion H1 () {}```로 선언한 컴포넌트를 JSX안에서 ```<H1> Hello world </H1>```로 작동 가능
3. ```=```기호 바로 뒤에 오는 속성  
   ```src={avatar}```는 아바타 변수를 읽지만, ```src="{avatar}"```는 문자열 "{avatar}"를 전달

## Using “double curlies”: CSS and other objects in JSX ("이중 중괄호"사용하기 : JSX에서 CSS와 다른 객체)
문자열, 숫자 및 기타 JavaScript 표현식 외에도 JSX로 객체를 전달할 수 있다.  
JSX에서 JS 객체를 전달하려면 다른 중괄호 쌍으로 객체를 감싸야 합니다. ```person={{ name: "Hedy Lamarr", inventions: 5 }```  
첫 번째 중괄호는 JSX내에서 JS 문법을 사용하겠다는 선언, 두 번째 중괄호는 객체의 중괄호  
이 때, 속성은 마찬가지로 거의다 카멜 케이스라는 것을 기억하자!  

> ## 컴포넌트를 만들 때 구조 분해 할당을 잘 사용하자!
> 컴포넌트를 선언하면서 객체의 구조 분해 할당을 잘 사용할 수록 깔끔하고 간결한 코드를 만들 수 있다.
> ```javascript
> const person = {
>   name: 'Gregorio Y. Zara',
>   theme: {
>     backgroundColor: 'black',
>     color: 'pink'
>   }
> };
> 
> export default function TodoList() {
>   return (
>     <div style={person.theme}>
>       <h1>{person.name}'s Todos</h1>
>       <img
>         className="avatar"
>         src="https://i.imgur.com/7vQD0fPs.jpg"
>         alt="Gregorio Y. Zara"
>       />
>     </div>
>   );
> }
> ```
> 위와 같은 코드에서 person을 TodoList의 props로 내려주면서 구조분해할당을 사용해보자.
> 첫 번째 방법은 내가 제일 많이 사용해왔던 방식!  
> ```javascript
> const person = {
>   name: 'Gregorio Y. Zara',
>   theme: {
>     backgroundColor: 'black',
>     color: 'pink'
>   }
> };
> 
> function TodoList({person}) {
>   const {name, theme} = person;
>   return (
>     <div style={theme}>
>       <h1>{name}'s Todos</h1>
>       <img
>         className="avatar"
>         src="https://i.imgur.com/7vQD0fPs.jpg"
>         alt="Gregorio Y. Zara"
>       />
>     </div>
>   );
> }
> 
> export default function App() {
>   return <TodoList person={person}/>
> }
> ```
> 하지만 이런 방식보다 더 간결하게 할 수 있는 방법이 있다. parameter에서 바로 구조 분해 해버리는 것!
> ```javascript
> const person = {
>   name: 'Gregorio Y. Zara',
>   theme: {
>     backgroundColor: 'black',
>     color: 'pink'
>   }
> };
> 
> function TodoList({person : {name, theme}}) {
>   return (
>     <div style={theme}>
>       <h1>{name}'s Todos</h1>
>       <img
>         className="avatar"
>         src="https://i.imgur.com/7vQD0fPs.jpg"
>         alt="Gregorio Y. Zara"
>       />
>     </div>
>   );
> }
> 
> export default function App() {
>   return <TodoList person={person}/>
> }
> ```
<br>

## JavaScript in JSX with Curly Braces Reacp (JSX에서 JS 사용하기 요약)
- 따옴표 안의 JSX 속성은 문자열로 전달
- 중괄호를 사용하면 JavaScript 로직과 변수를 마크업으로 가져올 수 있다.
- 중괄호는 JSX 태그 콘텐츠 내부 또는 속성의 = 바로 뒤에서 작동
- {{  }} 는 특별한 구문이 아니라 JSX 중괄호 안에 들어 있는 JavaScript 객체
<br>
  
## JavaScript in JSX with Curly Braces Try out some challenges (JSX에서 JS 사용하기 도전 과제)
### Q1. Fix the mistake
문제 :  
This code crashes with an error saying Objects are not valid as a React child:
```javascript
// App.js
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```
해결 :  
12번째 줄에 중괄호 안에 person이라는 객체만 들어있다. 객체만 들어가면 에러! 객체의 속성으로 부르자!
```javascript
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```

### Q2. Extract information into an object
문제 :  
Extract the image URL into the person object.
```javascript
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```
해결 :  
person 객체안에 img url을 담는 속성을 하나 만들고 그 값을 넣어주자.  
```javascript
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  },
  imgUrl : "https://i.imgur.com/7vQD0fPs.jpg"
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src={person.imgUrl}
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```

### Q3. Write an expression inside JSX curly braces
문제 :  
In the object below, the full image URL is split into four parts: base URL, imageId, imageSize, and file extension.  
We want the image URL to combine these attributes together:  
base URL (always 'https://i.imgur.com/'), imageId ('7vQD0fP'), imageSize ('s'), and file extension (always '.jpg').  
However, something is wrong with how the <img> tag specifies its src. Can you fix it?
```javascript
const baseUrl = 'https://i.imgur.com/';
const person = {
  name: 'Gregorio Y. Zara',
  imageId: '7vQD0fP',
  imageSize: 's',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="{baseUrl}{person.imageId}{person.imageSize}.jpg"
        alt={person.name}
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```
해결 :  
url 위치에 백틱을 사용하여 이미지 url을 넣도록 수정  
```javascript
const baseUrl = 'https://i.imgur.com/';
const person = {
  name: 'Gregorio Y. Zara',
  imageId: '7vQD0fP',
  imageSize: 's',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src={`${baseUrl}${person.imageId}${person.imageSize}.jpg`}
        alt={person.name}
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```
<br>
  
  
# 5. Passing Props to a Component (컴포넌트에 props 전달하기)
props는 컴포넌트 끼리 통신하기 위해 사용한다. 모든 부모 컴포넌트는 props를 이용하여 자식 컴포넌트에게 정보를 전달한다.  
props는 HTML의 속성(attribute)가 아니라 **객체, 배열, 함수를 포함한 모든 JS 값을 전달**할 수 있다.  

## 컴포넌트에 props를 전달하는 방법
### STEP1. 자식 컴포넌트에 props 전달하기
부모 컴포넌트에서 자식컴포넌트를 사용할 때, props를 전달한다.  
JSX 태그에 전달하는 방식을 사용하고, 속성명은 자식 컴포넌트의 인자명을 사용한다.  
```javascript
export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}
      size={100}
    />
  );
}
```

### STEP2. 자식 컴포넌트 내부에서 props 읽기
자식 컴포넌트에서 함수에 parameter 내려주는 방식과 동일하다. default 값 지정하는 방법도 동일하다.  
단, 일반 함수와 달리 props는 유일한 인자로써 **하나의 객체로 전달**되기 때문에 parameter 부분에서 꼭! **구조분해할당을 사용**해야 한다.
```javascript
function Avatar({ person, size=100 }) {
  return (
    <img
      className="avatar"
      alt={person.name}
      width={size}
      height={size}
    />
  );
}
```
> Props let you think about parent and child components independently. 이거 이해 안되용...

> #### 컴포넌트 내에서 props의 객체와 그 객체의 속성 모두 사용할 때
> props의 객체 전체와 그 안에 있는 속성을 동시에 사용할 때, 객체만 받아와서 사용하지 않고 받아올 때 동시에 불러와도 된다.
> ```javascript
> function Avatar({
>   person,
>   person : { name },
>   size }) {
>   return (
>     <img
>       className="avatar"
>       alt={name}
>       url={geturl(person)}  // geturl이라는 함수가 정의되었다고 가정하자.
>       width={size}
>       height={size}
>     />
>   );
> }
> ```
<br>
  
## 컴포넌트에서 props를 읽는 방법 
props를 읽는 방법은 위에서 언급한 것처럼 props는 유일한 인자로써 **하나의 객체로 전달**한다.  
보통은 전체 props 자체를 필요로 하지는 않기에, 개별 props로 구조분해한다.  
만약에 전달 받은 props 자체를 다음 컴포넌트에 그대로 props로 내려준다면, 이때는 spread 문법을 사용할 수 있다. 
하지만, 이런 경우는 자제하는 것이 좋으며 컴포넌트를 분리하여 JSX로써 children을 내려주는 것이 좋다.
~props drilling 때문일까?~
```javascript
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
```
<br>
  
## props default 지정 시 유의 사항
props에 default 지정할 땐 함수에 default 값 지정하는 방식과 동일하다.  
여기서 유의해야할 점은 props를 내려줄 때 null 혹은 undefined로 내려주는 경우이다.  
```size={undefined}``` 로 내려준다면 default값을 사용하지만, ```size={null}``` 또는 ```size={0}```으로 내려줄 땐, default값을 사용하지 않는다.  
why? undefined는 내려올 것이라 예상했지만 내려오지 않은 값이고, null과 0은 개발자가 직접 지정한 값이기 때문!!!  
<br>
  
## 컴포넌트에 JSX를 전달하는 방법
컴포넌트에 JSX를 전달하는 방법은 **children**으로 내려주는 것이다.  
컴포넌트 열리고 닫는 구문 사이에 JSX 빌트인 태그를 중첩한다면 children이라는 이름으로 props를 받는다.  
빌트인 태그가 아닌 컴포넌트를 사용할 수도 있다.  
```javascript
import Avatar from './Avatar.js';

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}
```
자식 컴포넌트가 무엇을 rendering하는지 부모 컴포넌트는 "알아야 할" 필요가 없다.  
children props을 가지고 있는 컴포넌트는 부모 컴포넌트가 임의로 JSX를 "채울" 수 있는 "구멍"을 가진 것이다.  
![props 구조](https://react-ko.dev/images/docs/illustrations/i_children-prop.png){: width="100" height="100"}
<br>
  
## 시간에 따라 props가 변하는 방식
props는 컴포넌트의 데이터를 처음에만 반응하는 것이 아니라 모든 시점에 대해 반응한다.  
props의 변화, 시간의 변화 등에 대해 변경된다.  
**Don’t try to “change props”.**  
사용자 입력에 반응해야 하는 경우에는 props가 아닌 *set state를 사용*하자.  
<br>

## Passing Props to a Component Recap (컴포넌트에 props 전달하기 요약)
- Props를 전달하려면 HTML 속성 사용할 때와 마찬가지로 JSX에 props를 추가
- Props를 읽으려면 구조 분해 구문을 사용
- 기본값을 지정할 수 있으며, 이는 누락되거나 undefined 인 props에 사용
- 모든 props에 전개 구문을 사용할 수 있지만, 과도하게 사용 X
- ```<Card><Avatar /></Card>```와 같이 중첩된 JSX는 Card컴포넌트의 children prop로 표시
- Props는 읽기 전용 스냅샷으로, 렌더링할 때마다 새로운 버전의 props를 받습니다.
- Props는 변경할 수 없다. 상호작용이 필요한 경우 state를 설정해야 합니다.
<br> 
  
## Passing Props to a Component Try out some challenges (컴포넌트에 props 전달하기 도전 과제)
### Q1. Extract a component
문제:  
This Gallery component contains some very similar markup for two profiles.  
Extract a Profile component out of it to reduce the duplication. You’ll need to choose what props to pass to it.  
```javascript
// App.js
import { getImageUrl } from './utils.js';

export default function Gallery() {
  return (
    <div>
      <h1>Notable Scientists</h1>
      <section className="profile">
        <h2>Maria Skłodowska-Curie</h2>
        <img
          className="avatar"
          src={getImageUrl('szV5sdG')}
          alt="Maria Skłodowska-Curie"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            physicist and chemist
          </li>
          <li>
            <b>Awards: 4 </b> 
            (Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)
          </li>
          <li>
            <b>Discovered: </b>
            polonium (element)
          </li>
        </ul>
      </section>
      <section className="profile">
        <h2>Katsuko Saruhashi</h2>
        <img
          className="avatar"
          src={getImageUrl('YfeOqp2')}
          alt="Katsuko Saruhashi"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            geochemist
          </li>
          <li>
            <b>Awards: 2 </b> 
            (Miyake Prize for geochemistry, Tanaka Prize)
          </li>
          <li>
            <b>Discovered: </b>
            a method for measuring carbon dioxide in seawater
          </li>
        </ul>
      </section>
    </div>
  );
}
```
```javascript
// utils.js
export function getImageUrl(imageId, size = 's') {
  return (
    'https://i.imgur.com/' +
    imageId +
    size +
    '.jpg'
  );
}
```
해결 : 
1. section 태그를 기준으로 Profile 컴포넌트를 만든다.
2. 사람의 정보를 객체로 만든다.
```javascript
// App.js
import { getImageUrl } from "./utils.js";

export default function Gallery() {
  const person1 = {
    name: "Maria Skłodowska-Curie",
    url: "szV5sdG",
    profession: "physicist and chemist",
    awards: [
      "Nobel Prize in Physics",
      "Nobel Prize in Chemistry",
      "Davy Medal",
      "Matteucci Medal"
    ],
    discovered: "polonium (element)"
  };

  const person2 = {
    name: "Katsuko Saruhashi",
    url: "YfeOqp2",
    profession: "geochemist",
    awards: ["Miyake Prize for geochemistry", "Tanaka Prize"],
    discovered: "a method for measuring carbon dioxide in seawater"
  };
  return (
    <div>
      <h1>Notable Scientists</h1>
      <Profile person={person1} />
      <Profile person={person2} />
    </div>
  );
}

function Profile({
  person: { name, url, imgSize=70, profession, awards, discovered }
}) {
  return (
    <section className="profile">
      <h2>{name}</h2>
      <img
        className="avatar"
        src={getImageUrl(url)}
        alt={name}
        width={imgSize}
        height={imgSize}
      />
      <ul>
        <li>
          <b>Profession: </b>
          {profession}
        </li>
        <li>
          <b>Awards: {awards.length} </b>({awards.join(", ")})
        </li>
        <li>
          <b>Discovered: </b>
          {discovered}
        </li>
      </ul>
    </section>
  );
}
```

### Q2. Adjust the image size based on a prop
문제 :  
In this example, Avatar receives a numeric size prop which determines the <img> width and height. The size prop is set to 40 in this example.  
However, if you open the image in a new tab, you’ll notice that the image itself is larger (160 pixels).  
The real image size is determined by which thumbnail size you’re requesting.  
Change the Avatar component to request the closest image size based on the size prop.  
Specifically, if the size is less than 90, pass 's' (“small”) rather than 'b' (“big”) to the getImageUrl function.  
Verify that your changes work by rendering avatars with different values of the size prop and opening images in a new tab.  
```javascript
// App.js
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person, 'b')}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <Avatar
      size={40}
      person={{ 
        name: 'Gregorio Y. Zara', 
        imageId: '7vQD0fP'
      }}
    />
  );
}
```
```javascript
// utils.js
export function getImageUrl(person, size) {
  return (
    'https://i.imgur.com/' +
    person.imageId +
    size +
    '.jpg'
  );
}
```
해결 :  
삼항연산자를 사용하여 size가 90보다 작으면 s 아니면 b 를 반환하도록 한다.
```javascript
// App.js
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person, size < 90 ? 's' : 'b')}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <Avatar
      size={40}
      person={{ 
        name: 'Gregorio Y. Zara', 
        imageId: '7vQD0fP'
      }}
    />
  );
}
```

### Q3. Passing JSX in a children prop
문제 :  
Extract a Card component from the markup below, and use the children prop to pass different JSX to it:
```javascript
// App.js
export default function Profile() {
  return (
    <div>
      <div className="card">
        <div className="card-content">
          <h1>Photo</h1>
          <img
            className="avatar"
            src="https://i.imgur.com/OKS67lhm.jpg"
            alt="Aklilu Lemma"
            width={70}
            height={70}
          />
        </div>
      </div>
      <div className="card">
        <div className="card-content">
          <h1>About</h1>
          <p>Aklilu Lemma was a distinguished Ethiopian scientist who discovered a natural treatment to schistosomiasis.</p>
        </div>
      </div>
    </div>
  );
}
```
해결 : 
반복되는 div 태그와 children 을 사용한 Card 컴포넌트를 만든다.  
```javascript
export default function Profile() {
  return (
    <div>
      <Card>
        <h1>Photo</h1>
        <img
          className="avatar"
          src="https://i.imgur.com/OKS67lhm.jpg"
          alt="Aklilu Lemma"
          width={70}
          height={70}
        />
      </Card>
      <Card>
        <h1>About</h1>
        <p>Aklilu Lemma was a distinguished Ethiopian scientist who discovered a natural treatment to schistosomiasis.</p>
      </Card>
    </div>
  );
}

function Card ({ children }) {
  return (
    <div className="card">
      <div className="card-content">
        {children}
      </div>
    </div>
  )
}
```
<br>

  
# 6. Conditional Rendering (조건부 렌더링)
컴포넌트는 조건에 따라 다른 화면을 보여주거나 보여주지 않아야하는 경우가 있다.  
이런 경우에 ```if``` 문, ```&&```, ```? :``` 연산자 같은 JavaScript 문법을 사용하여 처리한다.  

## 조건문 ( if )
if문은 JSX return문에서 사용할 수 없기 때문에 조건문을 담은 컴포넌트를 이용해 조건에 대해 처리한다.  
> 특정 조건에 대해 반환하고 싶지 않다면 null을 사용해도 되지만 혼동을 줄 수 있으므로, 특정 조건의 반대에 대한 정보만 반환하자.  
```javascript
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Danee's Packing List</h1>
      <ul>
        <Item isPacked={false} name="Laptop Computer" />
        <Item isPacked={true} name="Notebook" />
        <Item isPacked={false} name="A pencil" />
      </ul>
    </section>
  );
}
```
<br>

## 삼항 연산자 ( ? : )
위의 if 문은 같은 <li> 구문을 반복하고 있다. 공통으로 사용하는 구문에서 간결하게 if 문을 사용하고 싶다면 삼항 연산자를 사용한다.  
삼항 연산자는 JSX 안에서 사용할 수 있으므로 간결하다면 자식 컴포넌트를 만들지 않아도 된다.  
간단하기 때문에 자주 사용하지만 중첩된 조건 마크업이 너무 많아 컴포넌트가 지저분해지면 자식 컴포넌트를 추출하여 정리하는 것을 고려해야 한다.  
```javascript
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {isPacked
        ? <del>{ name + ' ✔' }</del>
        : name}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Danee's Packing List</h1>
      <ul>
        <Item isPacked={false} name="Laptop Computer" />
        <Item isPacked={true} name="Notebook" />
        <Item isPacked={false} name="A pencil" />
      </ul>
    </section>
  );
}
```
<br>
  
## 논리 AND 연산자 ( && )
또다른 간결한 구문이 AND 연산자이다.  
React 컴포넌트 내에서 조건이 참일 때 일부 JSX를 렌더링하거나 아무것도 렌더링하지 않으려 할 때 자주 사용한다.  
*만약 isPacked이면 (&&) 체크 표시를 렌더링하고, 그렇지 않으면 아무것도 렌더링하지 않는다.*  
> 이때 ```&&``` 왼쪽에 falsy, truthy 형태를 넣지 않도록 하자.
> 0이나 빈칸처럼 falsy인 형태를 넣더라도 값이 있다고 인식하여 해당 값을 반환한다.  
> falsy를 꼭 사용하고 싶다면 ```!!``` 을 사용하여 boolean 형으로 변경해주자.  
```javascript
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✔'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Danee's Packing List</h1>
      <ul>
        <Item isPacked={false} name="Laptop Computer" />
        <Item isPacked={true} name="Notebook" />
        <Item isPacked={false} name="A pencil" />
      </ul>
    </section>
  );
}
```
<br>

위의 방식이 어렵거나 가독성에 어려움을 주거나 다른 코드에 방해가 된다면 if문에서 변수를 활용할 수 있다.
```javascript
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent += ' ✔'
  }
  return (
    <li className="item">
      {itemContent}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Danee's Packing List</h1>
      <ul>
        <Item isPacked={false} name="Laptop Computer" />
        <Item isPacked={true} name="Notebook" />
        <Item isPacked={false} name="A pencil" />
      </ul>
    </section>
  );
}
```
<br>
  
## Conditional Rendering Recap (조건부 렌더링 요약)
- React에서는 JavaScript로 분기 로직을 제어한다.
- if문을 사용해서 조건부로 JSX 표현식을 반환
- 중괄호를 사용하여 일부 JSX를 변수에 조건부로 저장한 다음 다른 JSX 안에 포함할 수 있다.
- JSX에서 ```{cond ? <A /> : <B />}``` => “cond가 true이면 ```<A />```를 렌더링하고, 그렇지 않으면 ```<B />```를 렌더링하라”
- JSX에서 {cond && <A />} => ”cond가 있으면 ```<A />```를 렌더링하고, 그렇지 않으면 아무것도 렌더링하지 말라”를 의미합니다.
- 단축용법은 흔히 쓰이지만, 만약 if를 선호한다면 굳이 사용하지 않아도 된다.
<br>
  
## Conditional Rendering Try out some challenges (조건부 렌더링 도전과제)
### Q1. Show an icon for incomplete items with ? :
문제 :  
Use the conditional operator (cond ? a : b) to render a ❌ if isPacked isn’t true.
  
해결 :  
삼항연산자를 사용하여 true일 때는 체크 표시, false일 땐 엑스 표시를 반환한다.
```javascript
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked ? '✔' : '❌'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

### Q2. Show the item importance with &&
문제 :  
In this example, each Item receives a numerical importance prop.  
Use the && operator to render ”(Importance: X)” in italics, but only for items that have non-zero importance.  
Your item list should end up looking like this: Don’t forget to add a space between the two labels!  
- Space suit (Importance: 9)
- Helmet with a golden leaf
- Photo of Tam (Importance: 6)  
  
해결 :  
importance가 0을 기준으로 표출되고 안되고를 결정하기 때문에 AND 연산자를 사용한다.
```javascript
function Item({ name, importance }) {
  return (
    <li className="item">
      {name} {importance > 0 && <i>(Importance: {importance})</i>}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          importance={9} 
          name="Space suit" 
        />
        <Item 
          importance={0} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          importance={6} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

### Q3. Refactor a series of ? : to if and variables
문제 :  
This Drink component uses a series of ? : conditions to show different information depending on whether the name prop is "tea" or "coffee".  
The problem is that the information about each drink is spread across multiple conditions.  
Refactor this code to use a single if statement instead of three ? : conditions.  
Once you’ve refactored the code to use if, do you have further ideas on how to simplify it?  
  
해결 1 :  
이게 맞나? 싶을 정도로 길다. 사실 if 문으로 변수를 받을 수 있지만 귀찮아서...그만....  
```javascript
function Drink({ name }) {
  if (name === "tea") {
    return (
      <section>
        <h1>{name}</h1>
        <dl>
          <dt>Part of plant</dt>
          <dd>leaf</dd>
          <dt>Caffeine content</dt>
          <dd>15–70 mg/cup</dd>
          <dt>Age</dt>
          <dd>4,000+ years</dd>
        </dl>
      </section>
    );
  }

  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>bean</dd>
        <dt>Caffeine content</dt>
        <dd>80–185 mg/cup</dd>
        <dt>Age</dt>
        <dd>1,000+ years</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}
```
  
해결2 :  
if 문을 사용하지 않고 객체를 사용하여 구현했다.  
```javascript
function Drink({ name }) {
  const drink = {
    tea: {
      plant: "leaf",
      caffeine: "15–70 mg/cup",
      age: "4,000+ years"
    },
    coffee: {
      plant: "bean",
      caffeine: "80–185 mg/cup",
      age: "1,000+ years"
    }
  };

  const pick = drink[name];
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{pick.plant}</dd>
        <dt>Caffeine content</dt>
        <dd>{pick.caffeine}</dd>
        <dt>Age</dt>
        <dd>{pick.age}</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}
```
<br>


# 7. Rendering Lists
같은 컨포넌트를 사용하여 반복적으로 보여주고 싶을 때 (예. 댓글, 게시판) JS 배열 메소드를 사용(**map(), filter()**)하여 표출한다.  
<br>

## map()
댓글 목록이나 프로필 이미지와 같이 같은 컨포넌트를 중복으로 사용할 때 map() 메소드를 활용한다.  
지금까지 나는 컴포넌트 jsx 안에서 map 을 바로 사용했는데 공식문서 에서는 따로 사용한다.  
이렇게 사용하는 것이 더 깔끔한 듯!
```javascript
const people = [
  '박혁거세 : 왕',
  '정몽주 : 외교관',
  '이순신 : 장군',
  '강감찬 : 장군',
  '김홍도 : 화가'
];

export default function List() {
  const listItems = people.map(person =>
    <li>{person}</li>
  );
  return <ul>{listItems}</ul>;
}
```

## filter()
배열 속에서 특정 조건에 맞는 사람을 표출하고 싶을 때 filter() 메소드를 활용한다.  
filter()는 조건에 맞는 원소를 추출하는 것이기 때문에 항상 map과 함께 쓰인다.
```javascript
const people = [
  {id : 0, name : '박혁거세', job : '왕'},
  {id : 1, name : '정몽주', job : '외교관'},
  {id : 2, name : '이순신', job : '장군'},
  {id : 3, name : '강감찬', job : '장군'},
  {id : 4, name : '김홍도', job : '화가'},
];

export default function List() {
  const generals = people.filter(person =>
    person.job === '장군'
  );
  const listItems = generals.map(person =>
    <li>{person.name} : {person.job}</li>
  );
  return <ul>{listItems}</ul>;
}
```

## 반복 컴포넌트는 key가 필수다!
map()을 사용하여 중복해서 생성되는 컴포넌트는 key를 할당해야만 한다.  
해당 배열의 항목들 사이에서 고유하게 식별할 수 있는 문자열 또는 숫자인 key를 부여한다.  
배열이 재배열될 수도 있고, 삭제될 수 있고, 변경될 수 있기 때문에 item의 위치를 정확하게 알 수 있는 key가 중요하다.  
즉석에서 key를 생성하는 방법은 key가 항상 바뀌기 때문에 고유한 값을 가진 id를 데이터에 포함하여 그 id를 key로 사용한다.  
*key는 컴포넌트에서 props로 받는 것이 아니라 react 상에서 힌트로만 사용*한다. 그러므로 그 id를 받고 싶다면 따로 id를 넘겨주어야한다.
- key를 얻을 수 있는 곳
  + database에서 받아오는 데이터 : 고유한 db의 id나 pk를 사용하면 된다.
  + 로컬에서 생성되는 데이터 : 카운터(비추), uuid, Crypto: randomUUID() 사용
- key 규칙
  + key는 다른 항목간에 unique한 값을 가져야 한다.
  + key는 변경되면 안된다.
```javascript
const people = [
  {id : 0, name : '박혁거세', job : '왕'},
  {id : 1, name : '정몽주', job : '외교관'},
  {id : 2, name : '이순신', job : '장군'},
  {id : 3, name : '강감찬', job : '장군'},
  {id : 4, name : '김홍도', job : '화가'},
];

export default function List() {
  const generals = people.filter(person =>
    person.job === '장군'
  );
  const listItems = generals.map(person =>
    <li key={person.id} id={person.id}>{person.name} : {person.job}</li>
  );
  return <ul>{listItems}</ul>;
}
```
<br>
  
> ### 배열의 각 항목에 여러 개의 DOM 노드 표시하기
> jsx를 return할 때 무조건 하나의 태그로 묶어야 하기 때문에 여러 개의 태그가 있을 때 빈 태그의 fragment로 묶어서 반환한다.  
> 하지만 map을 사용했을 경우에 빈 태그를 사용하면 key 값을 넘겨줄 수 없게 된다.
> 이럴 때 해결 방법은 2가지
> 1. 단일 ```<div>```로 묶기
> 2. 명시적인 Fragment 사용하기
> ```javascript
> import { Fragment } from 'react';
> ...
> export default function List() {
>   const listItems = people.map(person =>
>     <Fragment key={person.id}>
>       <li>{person.name}</li>
>       <li>{person.job}</li>
>     </Fragment>
>   );
>   return <ul>{listItems}</ul>;
> }
> ```
<br>
  
## Rendering Lists Try out some challenges (배열 렌더링하기 도전 과제)
### Q1. Splitting a list in two
문제 :  
This example shows a list of all people.  
Change it to show two separate lists one after another: Chemists and Everyone Else.  
Like previously, you can determine whether a person is a chemist by checking if ```person.profession === 'chemist'```.  
  
해결 :  
```<li>``` 부분이 반복되므로 따로 컴포넌트로 빼주어서 해결했다.  
filter를 2번 안쓰고 각각 빈 배열로 2개 만들어서 forEach() 메소드를 사용하여 빼줘도 될 것 같다.  
```javascript
// data.js
export const people = [{
  id: 0,
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}, {
  id: 1,
  name: 'Mario José Molina-Pasquel Henríquez',
  profession: 'chemist',
  accomplishment: 'discovery of Arctic ozone hole',
  imageId: 'mynHUSa'
}, {
  id: 2,
  name: 'Mohammad Abdus Salam',
  profession: 'physicist',
  accomplishment: 'electromagnetism theory',
  imageId: 'bE7W1ji'
}, {
  id: 3,
  name: 'Percy Lavon Julian',
  profession: 'chemist',
  accomplishment: 'pioneering cortisone drugs, steroids and birth control pills',
  imageId: 'IOjWm71'
}, {
  id: 4,
  name: 'Subrahmanyan Chandrasekhar',
  profession: 'astrophysicist',
  accomplishment: 'white dwarf star mass calculations',
  imageId: 'lrWQx8l'
}];
```
```javascript
// util.js
export function getImageUrl(person) {
  return (
    'https://i.imgur.com/' +
    person.imageId +
    's.jpg'
  );
}
```
```javascript
// App.js
import { people } from './data.js';
import { getImageUrl } from './utils.js';

function MapList(arr) {
  return (
    arr.map(person =>
      <li key={person.id}>
        <img
          src={getImageUrl(person)}
          alt={person.name}
        />
        <p>
          <b>{person.name}:</b>
          {' ' + person.profession + ' '}
          known for {person.accomplishment}
        </p>
      </li>
    )
  )
}
export default function List() {
  const chemiList = people.filter(person => person.profession === "chemist")
  const nonChemiList = people.filter(person => person.profession !== "chemist")

  return (
    <article>
      <h1>Scientists</h1>
      <ul>{MapList(chemiList)}</ul>
      <ul>{MapList(nonChemiList)}</ul>
    </article>
  );
}
```

### Q2. Nested lists in one component
문제 :  
Make a list of recipes from this array! For each recipe in the array, display its name as an <h2> and list its ingredients in a <ul>.  
  
해결 :  
recipe를 map 메소를 통해 레시피 별로 작성하고, 그 안에 있는 성분도 배열이기 때문에 한번 더 map() 메소드를 사용한다.  
```javascript
import { recipes } from './data.js';

export default function RecipeList() {
  const recipe = recipes.map(recipe =>
    <div key={recipe.id}>
      <h2>{recipe.name}</h2>
      <ul>{recipe.ingredients.map(ingredient =>
        <li>{ingredient}</li>
        )}
      </ul>
    </div>
  )
  return (
    <div>
      <h1>Recipes</h1>
      {recipe}
    </div>
  );
}
```

### Q3. Extracting a list item component
문제 :  
This RecipeList component contains two nested map calls.   
To simplify it, extract a Recipe component from it which will accept id, name, and ingredients props.  
Where do you place the outer key and why?
  
해결 :  
key를 Recipe JSX에서 div 태그로 묶고 있기 때문에 묶고 있는 div 태그에 key 값을 준다.  
```javascript
import { recipes } from "./data.js";

function Recipe({ id, name, ingredients }) {
  return (
    <div key={id}>
      <h2>{name}</h2>
      <ul>
        {ingredients.map((ingredient) => (
          <li key={ingredient}>{ingredient}</li>
        ))}
      </ul>
    </div>
  );
}
export default function RecipeList() {
  return (
    <div>
      <h1>Recipes</h1>
      {recipes.map((recipe) => (
        <Recipe {...recipe} key={recipe.id} />
      ))}
    </div>
  );
}
```

### Q4. 
문제 :  
  
해결 :  
```javascript

```

<br>
  
# 8. Keeping Components Pure
