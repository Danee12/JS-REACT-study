사용자의 입력 혹은 동작에 따라 값이 update될 때가 있다.  
시간이 지남에 따라 변하는 데이터를 **state**라고 한다.  
이번 챕터에서는 상호작용을 처리하고, state를 업데이트하고, 시간에 따라 다른 출력을 표시하는 컴포넌트를 작성하는 방법에 대해 설명한다.  

# 1. Responding to events
```<button>```과 같은 기본 제공 컴포넌트는 ```onClick```과 같은 기본 제공 브라우저 이벤트만 지원한다.  
JSX에서는 이벤트 핸들러 함수를 정의하여 ```onClick```과 같은 이벤트에 적용함으로써 더 다양한 상호작용을 할 수 있다.  

## Event Handler 작성하기
이벤트 핸들러를 함수로 작성하여 적절한 태그에 props로 내려준다.  
button을 클릭하면 alert를 띄워주는 효과를 넣어보자.  
1. Button 컴포넌트 안에 handleClick이라는 함수를 선언  
2. 해당 함수 내부의 로직((alert을 사용하여 메시지 표시))을 구현  
3. JSX의 <button>에 onClick={handleClick}를 추가합니다.  
```javascript
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```
- 이벤트 핸들러 규칙  
  + 일반적으로 컴포넌트 안에 정의  
  + 이름은 ```handle```로 시작하고 뒤에 이벤트 이름이 오도록 함 ex. handleClick  
  + 인라인으로 작성할 수 있다. (함수가 짧 때) 또한, 인라인으로 작성할 때는 익명 함수로 작성  
  + props로 내려줄 때는 *호출하는 것이 아니라 **전달***  
  + 이벤트 핸들러는 컴포넌트 내부에서 선언되기 때문에 컴포넌트의 props에 접근할 수 있다.  
  + 자식의 이벤트 핸들러를 props로 받을 때 이름을 ```on```으로 시작하고 뒤에 대문자가 오도록 한다.
    ```javascript
    // 이벤트 핸들러를 props로 받을 때 'on'으로 시작
    function Button({ onSmash, children }) {
      return (
        <button onClick={onSmash}>
          {children}
        </button>
      );
    }
    
    export default function App() {
      return (
        <div>
          // 인라인으로 익명함수 작성, 호출이 아닌 전달
          <Button onSmash={() => alert('Playing!')}>
            Play Movie
          </Button>
          <Button onSmash={() => alert('Uploading!')}>
            Upload Image
          </Button>
        </div>
      );
    }
    ```
<br>
  
## Event Propagation
이벤트 핸들러는 자신의 컴포넌트에서만 작동하는 것이 아니라 트리 위로 올라가며 모두 작동한다. => **bubble** 또는 **propagate** 이라고 한다.  
```
<div onClick={() => {
    alert('You clicked on the toolbar!');
  }}>
    <button onClick={() => alert('Playing!')}>
      Play Movie
    </button>
  </div>
);
```
위와 같은 코드에서 Movie 버튼을 누르면 'Playing!' 이라는 알림창이 뜬 후 'You clicked on the toolbar!'라고 뜨면서 2가지 모두 작동한다.  
이는 중지하는 방법이 꼭 필요하다.  

### 전파 중지하기
이벤트 핸들러는 이벤트 객체를 유일한 인수로 받기 때문에 event를 줄여서 "e"로 많이 사용한다.  
이 객체를 사용하여 이벤트에 대한 정보를 읽을 수 있고 전파를 막을 수도 있다. => ```e.stopPropagation()```
```javascript
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();  // 전파 중지!!!! 
      onClick();
    }}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div onClick={() => {
      alert('You clicked div!');
    }}>
      <Button onClick={() => alert('Playing!')}>
        Play Movie
      </Button>
    </div>
  );
}
```

### default 동작 중지하기
일부 기본 브라우저 이벤트에는 연결된 default 동작들이 있다.  
예. ```<form>```에 onSubmit 이벤트는 버튼을 클릭하면 전체 페이지 로드  
이때, ```e.preventDefault()```를 호출하면 default 동작을 막을 수 있다.  
```javascript
export default function Signup() {
  return (
    <form onSubmit={e => {
      e.preventDefault();
      alert('Submitting!');
    }}>
      <input />
      <button>Send</button>
    </form>
  );
}
```
<br>
  
## Responding to events Recap (이벤트에 응답하기 요약)
- ```<button>```과 같은 태그의 요소에 함수를 prop으로 전달하여 이벤트를 처리할 수 있다.  
- 이벤트 핸들러는 호출이 아니라 전달해야 한다. *onClick={handleClick()} : X,  onClick={handleClick} : O*  
- 이벤트 핸들러 함수를 개별적으로 또는 인라인으로 정의할 수 있다.  
- 이벤트 핸들러는 컴포넌트 내부에 정의되므로 props에 액세스할 수 있다.  
- 부모에서 이벤트 핸들러를 선언하고 이를 자식에게 prop으로 전달할 수 있다.  
- 이름을 지정하여 이벤트 핸들러 prop을 직접 정의할 수 있다.  
- 이벤트는 위쪽으로 전파된다. => 방지하려면 첫 번째 인수에 ```e.stopPropagation()```을 호출하자.
- 이벤트에 원치 않는 기본 브라우저 동작이 있을 수 있다. => 방지하려면 ```e.preventDefault()```를 호출하자.
- 자식 핸들러에서 이벤트 핸들러 prop을 명시적으로 호출하는 것은 전파에 대한 좋은
<br>
  
## Responding to events Try out some challenges (이벤트에 응답하기 도전과제)
### Q1. Fix an event handler
문제 :  
Clicking this button is supposed to switch the page background between white and black.  
However, nothing happens when you click it. Fix the problem.  
(Don’t worry about the logic inside handleClick—that part is fine.)  
  
해결 :  
button의 onClick에 들어가는 이벤트 핸들러 함수인 handleClick이 전달되는 것이 아니라 호출되었기 때문에 작동 X  
```javascript
export default function LightSwitch() {
  function handleClick() {
    let bodyStyle = document.body.style;
    if (bodyStyle.backgroundColor === 'black') {
      bodyStyle.backgroundColor = 'white';
    } else {
      bodyStyle.backgroundColor = 'black';
    }
  }

  return (
    // 호출을 전달로 변경
    <button onClick={handleClick}>
      Toggle the lights
    </button>
  );
}
```

### Q2. Wire up the events
문제 :  
This ColorSwitch component renders a button. It’s supposed to change the page color.  
Wire it up to the onChangeColor event handler prop it receives from the parent so that clicking the button changes the color.  
After you do this, notice that clicking the button also increments the page click counter.  
Your colleague who wrote the parent component insists that onChangeColor does not increment any counters.  
What else might be happening?  
Fix it so that clicking the button only changes the color, and does not increment the counter.  
  
해결  :  
1) 컬러가 바뀌지 않는다 -> onChangeColor를 onClick에 적용  
2) 이벤트가 전파되어 카운트까지 올라간다. -> stopPropation() 적용  
```javascript
export default function ColorSwitch({
  onChangeColor
}) {
  return (
    <button onClick={(e) => {
      e.stopPropagation();
      onChangeColor();
    }}>
      Change color
    </button>
  );
}
```
<br>


# 2. State: A Component's Memory

---
## useState 훅으로 state 변수를 추가하는 방법
useState 훅이 반환하는 값 쌍
state 변수를 두 개 이상 추가하는 방법
state를 지역적이라고 하는 이유
