App이 커질수록 state를 구성하는 방법과 컴포넌트 간에 데이트가 흐르는 방법을 의도적으로 만들어야 한다.  
3장에서는 state를 구조적으로 잘 짜는 방법, state 업데이트 로직을 유지 관리하는 방법, 동떨어져 있는 컴포넌트 사이에 state를 공유하는 방법에 대해 배울 것이다.

# 1. Reacting to input with state
React는 코드에서 직접 UI를 수정하는 것이 아니라, state 별로 다양하게 시각적으로 표현하고자 하는 UI를 구현하여, input에 따라 반응하게 만든다.  
이는 표시할 내용을 선언하면 React가 UI를 업데이트하는 방법을 알아내어 반응한다. 이때 *선언*이라는 키워드에 집중하자.  
state 기반 사고방식으로 상호작용에 접근하는 방식에 대해 배워보자.  
  
## 명령형 vs 선언형 프로그래밍
명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가와 가깝다.  
예시를 먼저 생각해보자. 가족과 함께 외식을 한다고 하면,  
- 명령형 방식 (HOW) : "12번 테이블 자리가 비어있습니다. 나와 우리 가족은 저 자리로 걸어가 앉을 것입니다."  
- 선언형 방식 (WHAT) : "네 명 앉을자리를 부탁해요"
<br>

위의 예시에서 보다시피 명령형은 웨이터가 해야할 일은 **어떻게** 해야할지 하나하나 명령을 하고 있으며, 선언형은 내가 **무엇을** 원하는지 말하고 있다.  
프로그래밍에서도 명령형은 한줄한줄 프로그램이 해야하는 일을 *command* 하는 것이고, 선언형은 메서드, 함수 등을 사용하여 *declare* 하는 것이다.  
이때 선언형 프로그래밍에서 사용하는 함수나 메서드 등은 이미 명령형으로 "어떻게"가 구현된 것들이 추상화 되어 있어야만 가능하다.  
코드로 예시를 살펴보자. 명령형에서는 해당하는 내용을 모두 구현했지만 선언형에서는 ```map()```를 사용하여 구현했다.  
이때, map과 같은 메서드, 함수의 내부 구동 원리는 이해하지 않아도 되며, 가독성이 훨씬 좋아진다는 장점이 있다.  
```javascript
// 배열을 파라미터로 받고 각 요소들의 값에 2를 곱하는 함수

// 명령형
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}

// 선언형
function double (arr) {
  return arr.map((item) => item * 2)
}
```
> 출처 : https://boxfoxs.tistory.com/430
<br>

## UI를 React로 구현하는 방법
### STEP 1. *Identify* your component’s different visual states
사용자에게 표시될 수 있는 UI의 다양한 *상태*를 모두 시각화해야 한다.  
다양한 시각적인 상태에 따른 component를 설계해야 하는데, 이때 storybook 또는 living styleguides라고 불리는 한 페이지에 모든 *상태*를 구현해놓는 페이지를 만들기도 한다.  
  
### STEP 2. *Determine* what triggers those state changes
*상태*가 변경되는 이유는 2가지로 정리할 수 있다. 이 두가지 모두 state 변수를 설정해야 한다.  
- 사람의 입력 : 버튼 클릭, 필드 입력, 링크 이동 등
- 컴퓨터의 입력 : 네트워크에서 응답 도착, 시간 초과, 이미지 로딩 등
<br>

상태가 변경되는 흐름을 시각화하는 과정은 흐름을 파악하는 것 뿐만 아니라 구현하기 전에 버그에 대해 예방할 수 있다.  
종이에 각 상태가 적힌 원을 그리고 각 상태 사이의 변경 사항을 화살표로 그려보자.  
![상태흐름도.png](https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.png&w=1920&q=75)

### STEP 3. *Represent* the state in memory using useState
컴포넌트의 시각적 *상태* 를 ```useState```를 사용하여 표현한다.  
이 과정은 **단순함**이 중요하기 때문에, 가능한 적은 수의 state를 사용한다.  
반드시 필요한 state부터 생성하여 시각적 상태 중 어떤 상태를 표시할지 나타내는 state 변수가 필요하다.  
이 과정에서 처음부터 완벽한 구조가 짜여지는 것은 힘들다. state를 계속 리팩토링하여 최적의 state가 되도록 하는 것도 굉장한 경험이 될 것이다.  

### STEP 4. *Remove* any non-essential state variables
state 변수는 중복과 불필요한 변수는 없어야 한다. 이를 통해 state가 사용자에게 보여주기를 원하는 UI를 나타내지 않는 경우를 방지하고자 한다.  
아래의 질문을 통해 essential state variables만 남기도록 하자.
- 이 state가 모순을 발생시키는가?
- 이미 존재하는 state에 같은 정보가 있는가?
- 다른 state를 뒤집으면 같은 정보가 되는가?
<br>


### STEP 5. *Connect* the event handlers to set the state
<br>

## Reacting to input with state Recap (state를 사용하여 input에 반응하기 요약)
- 선언형 프로그래밍은 UI를 세밀하게 관리(명령형)하지 않고 각 시각적 상태에 대해 UI를 기술하는 것을 의미한다.
- 컴포넌트를 개발할 때
  1. 모든 시각적 상태를 식별하자.
  2. 사람 및 컴퓨터가 상태 변화를 촉발하는 요인을 결정하자.
  3. useState로 상태를 모델링하자.
  4. 버그와 모순을 피하려면 비필수적인 state를 제거하자.
  5. 이벤트 핸들러를 연결하여 state를 설정하자.
<br>

## Reacting to input with state Try out some challenges (state를 사용하여 input에 반응하기 도전과제)
### Q1. Add and remove a CSS class
문제 :  
Make it so that clicking on the picture removes the background--active CSS class from the outer <div>, but adds the picture--active class to the <img>.  
Clicking the background again should restore the original CSS classes.  
Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border.  
Clicking outside the picture highlights the background, but removes the picture border highlight.  
  
풀이 :  
사진을 클릭했을 때 상태를 변경해주기 위한 state 변수를 하나 설정한다.  
배경을 클릭했을 때 false가 되고 사진을 클릭했을 때 true가 되어 설정하도록 하자.  
단, 배경은 사진을 품고 있기 때문에 클릭했을 때 true -> false로 순식간에 바뀐다. ```stopPropagation()```을 사용하여 전파를 막는다.  
state 변수 상태에 따라 className이 변경되기 때문에 맞춰서 수정한다.  
className은 따로 일반변수를 활용할 수도 있지만 한줄로 간단하게 만들 수 있기 때문에 JSX안에서 삼항연산자를 사용했다.  
```javascript
import { useState } from "react";

export default function Picture() {
  const [click, setClick] = useState(false);

  return (
    <div 
      className={click ? "background" : "background background--active"}
      onClick={() => setClick(false)}
    >
      <img
        className={click ? "picture picture--active" : "picture"}
        alt="Rainbow houses in Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
        onClick={(e) => {
          e.stopPropagation();
          setClick(true)
        }}
      />
    </div>
  );
}
```

### Q2. Profile editor
문제 :  
Here is a small form implemented with plain JavaScript and DOM. Play with it to understand its behavior:  
```javascript
function handleFormSubmit(e) {
  e.preventDefault();
  if (editButton.textContent === 'Edit Profile') {
    editButton.textContent = 'Save Profile';
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = 'Edit Profile';
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
}

function handleFirstNameChange() {
  firstNameText.textContent = firstNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function handleLastNameChange() {
  lastNameText.textContent = lastNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
This form switches between two modes: in the editing mode, you see the inputs, and in the viewing mode, you only see the result.  
The button label changes between “Edit” and “Save” depending on the mode you’re in.  
When you change the inputs, the welcome message at the bottom updates in real time.  
Your task is to reimplement it in React in the sandbox below.  
For your convenience, the markup was already converted to JSX, but you’ll need to make it show and hide the inputs like the original does.  
Make sure that it updates the text at the bottom, too!  
  
풀이 :  
먼저 이름을 담는 state와 수정 버튼을 클릭했는지의 상태를 담는 state를 만든다.  
버튼을 눌렀을 때 isEdit의 상태가 바뀌어야 하는데 form은 새로고침을 해주기 때문에 ```preventDefault()```을 사용하여 제한한다.  
isEdit의 상태에 따라 UI가 변경되도록 코드를 수정한다.  
```javascript
import { useState } from "react";

export default function EditProfile() {
  const [name, setName] = useState({ firstName: "Jane", lastName: "Jacobs" });
  const [isEdit, setIsEdit] = useState(false);

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsEdit(!isEdit);
      }}
    >
      <label>
        First name:{" "}
        {isEdit ? (
          <input
            value={name.firstName}
            onChange={(e) => {
              setName({ ...name, firstName: e.target.value });
            }}
          />
        ) : (
          <b>{name.firstName}</b>
        )}
      </label>
      <label>
        Last name:{" "}
        {isEdit ? (
          <input
            value={name.lastName}
            onChange={(e) => {
              setName({ ...name, lastName: e.target.value });
            }}
          />
        ) : (
          <b>{name.lastName}</b>
        )}
      </label>
      <button type="submit">{isEdit ? "Save Profile" : "Edit Profile"}</button>
      <p>
        <i>Hello, {name.firstName + " " + name.lastName}</i>
      </p>
    </form>
  );
}
```

### Q3. Refactor the imperative solution without React
문제 :  
Here is the original sandbox from the previous challenge, written imperatively without React: (2번에 있으니까 안가져옴)  
Imagine React didn’t exist. Can you refactor this code in a way that makes the logic less fragile and more similar to the React version?  
What would it look like if the state was explicit, like in React?  
If you’re struggling to think where to start, the stub below already has most of the structure in place.  
If you start here, fill in the missing logic in the updateDOM function. (Refer to the original code where needed.)  
  
풀이 :  
항상 react로 해오다가 명령형을 사용하니 신기했다.  
```javascript
let firstName = "Jane";
let lastName = "Jacobs";
let isEditing = false;

function handleFormSubmit(e) {
  e.preventDefault();
  setIsEditing(!isEditing);
}

function handleFirstNameChange(e) {
  setFirstName(e.target.value);
}

function handleLastNameChange(e) {
  setLastName(e.target.value);
}

function setFirstName(value) {
  firstName = value;
  updateDOM();
}

function setLastName(value) {
  lastName = value;
  updateDOM();
}

function setIsEditing(value) {
  isEditing = value;
  updateDOM();
}

function updateDOM() {
  if (isEditing) {
    editButton.textContent = "Save Profile";
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = "Edit Profile";
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
  firstNameText.textContent = firstName;
  lastNameText.textContent = lastName;
  helloText.textContent = "Hello " + firstName + " " + lastName + "!";
}

function hide(el) {
  el.style.display = "none";
}

function show(el) {
  el.style.display = "";
}

let form = document.getElementById("form");
let editButton = document.getElementById("editButton");
let firstNameInput = document.getElementById("firstNameInput");
let firstNameText = document.getElementById("firstNameText");
let lastNameInput = document.getElementById("lastNameInput");
let lastNameText = document.getElementById("lastNameText");
let helloText = document.getElementById("helloText");
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
<br>


# 2. Choosing the State Structure
state를 잘 구조화하면 수정과 디버깅이 편해지고 버그를 방지할 수 있다.  
state를 갖고 있는 component를 작성할 때, state 변수를 몇개나 쓸 것인지, 데이터를 어떤 형태로 사용할 것인지 정해야한다.  
이런 점을 고려하면서 state의 원칙을 살펴보자.  

## state 구조화 원칙
1. 연관된 state끼리 그룹화하자.  
   항상 2개 이상의 state가 동시에 변한다면 하나로 통합한다.  
   또한 사용자 정의 필드를 추가하는 것처럼 필요한 state 수가 사용자에 의해 변할 때 하나의 객체 state를 만들어 적용한다.  
2. state에서 모순은 피하자.  
   여러가지 state가 있을 때 서로 모순이 되거나 "불일치"해진다면 에러가 발생할 수 있다.  
3. 불필요한 state는 피하자.  
   렌더링 도중에 props나 기존의 state로 계산할 수 있다면 state로 새로 생성하지 않는다.  
   state 변수로 계산하는 일반 변수는 rendering 도중 자동으로 계산이 된다.  
   props로 받은 변수를 state의 초깃값으로 사용하지 말자. (단, 부모에서 변경될 때 연동이 되고 싶지 않다면 괜찮다.)  
4. state의 중복은 피하자.  
    동일한 데이터가 여러 state 변수 간에 또는 중첩된 객체 내에 중복되면 동기화 state를 유지하기가 어렵다.  
5. 깊게 중첩된 state는 피하자.
   깊게 계층화된 state는 업데이트하기 쉽지 않다. 최대한 "flat"하게 만들어야 한다.
   중첩된 state의 일부를 하위 컴포넌트로 이동하여 state 중첩을 줄일 수도 있다.  
<br>

## Choosing the State Structure Recap (state 구조 선택하기 요약)
- 두 개의 state 변수가 항상 함께 업데이트되는 경우 두 변수를 하나로 병합하는 것이 좋다.
- state 변수를 신중하게 선택하여 ‘불가능한’ state를 만들지 않도록 하자.
- state를 업데이트할 때 실수할 가능성을 줄이는 방식으로 state를 구성하자.
- 동기화 state를 유지할 필요가 없도록 불필요 및 중복 state를 피하자.
- 특별히 업데이트를 막으려는 경우가 아니라면 props를 state에 넣지 않는 것이 좋다.
- 선택과 같은 UI 패턴의 경우 객체 자체 대신 ID 또는 인덱스를 state로 유지한다.
- 깊게 중첩된 state를 업데이트하는 것이 복잡하다면 state를 평평하게 만들어 보자.
<br>

## Choosing the State Structure Try out some challenges (state 구조 선택하기 도전 과제)
### Q1. Fix a component that’s not updating
문제 :  
This Clock component receives two props: color and time.  
When you select a different color in the select box, the Clock component receives a different color prop from its parent component.  
However, for some reason, the displayed color doesn’t update. Why? Fix the problem.  

해결 :  
부모 컴포넌트에서 받아온 props를 새롭게 state 변수로 생성한다면, 색상이 변화하지 않는다.  
받은 props를 그대로 사용하자.  
```javascript
// import { useState } from 'react';

export default function Clock(props) {
  // const [color, setColor] = useState(props.color);
  return (
    <h1 style={{ color: props.color }}>
      {props.time}
    </h1>
  );
}
```

### Q2. Fix a broken packing list
문제 :  
This packing list has a footer that shows how many items are packed, and how many items there are overall.  
It seems to work at first, but it is buggy.  
For example, if you mark an item as packed and then delete it, the counter will not be updated correctly.  
Fix the counter so that it’s always correct.  
  
해결 :  
total과 packed state는 items state로 계산이 가능하기 때문에 items를 사용한다.  
```javascript
import { useState } from "react";
import AddItem from "./AddItem.js";
import PackingList from "./PackingList.js";

let nextId = 3;
const initialItems = [
  { id: 0, title: "Warm socks", packed: true },
  { id: 1, title: "Travel journal", packed: false },
  { id: 2, title: "Watercolors", packed: false }
];

export default function TravelPlan() {
  const [items, setItems] = useState(initialItems);
  // const [total, setTotal] = useState(3);
  // const [packed, setPacked] = useState(1);

  const total = items.length;
  const packed = items.filter((item) => item.packed === true).length;

  function handleAddItem(title) {
    setItems([
      ...items,
      {
        id: nextId++,
        title: title,
        packed: false
      }
    ]);
  }

  function handleChangeItem(nextItem) {
    // if (nextItem.packed) {
    //   setPacked(packed + 1);
    // } else {
    //   setPacked(packed - 1);
    // }
    setItems(
      items.map((item) => {
        if (item.id === nextItem.id) {
          return nextItem;
        } else {
          return item;
        }
      })
    );
  }

  function handleDeleteItem(itemId) {
    setItems(items.filter((item) => item.id !== itemId));
  }

  return (
    <>
      <AddItem onAddItem={handleAddItem} />
      <PackingList
        items={items}
        onChangeItem={handleChangeItem}
        onDeleteItem={handleDeleteItem}
      />
      <hr />
      <b>
        {packed} out of {total} packed!
      </b>
    </>
  );
}

```

### Q3. Fix the disappearing selection
문제 :  
There is a list of letters in state. When you hover or focus a particular letter, it gets highlighted.  
The currently highlighted letter is stored in the highlightedLetter state variable.  
You can “star” and “unstar” individual letters, which updates the letters array in state.  
This code works, but there is a minor UI glitch.  
When you press “Star” or “Unstar”, the highlighting disappears for a moment.  
However, it reappears as soon as you move your pointer or switch to another letter with keyboard.  
Why is this happening? Fix it so that the highlighting doesn’t disappear after the button click.  
  
해결 :  
letter 자체를 담지 말고 id를 담아서 그 위치를 정확하게 잡고 있자.  
```javascript
import { useState } from "react";
import { initialLetters } from "./data.js";
import Letter from "./Letter.js";

export default function MailClient() {
  const [letters, setLetters] = useState(initialLetters);
  const [highlightedId, setHighlightedId] = useState(null);

  function handleHover(letter) {
    setHighlightedId(letter.id);
  }

  function handleStar(starred) {
    setLetters(
      letters.map((letter) => {
        if (letter.id === starred.id) {
          return {
            ...letter,
            isStarred: !letter.isStarred
          };
        } else {
          return letter;
        }
      })
    );
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map((letter) => (
          <Letter
            key={letter.id}
            letter={letter}
            isHighlighted={letter.id === highlightedId}
            onHover={handleHover}
            onToggleStar={handleStar}
          />
        ))}
      </ul>
    </>
  );
}
```

### Q4. Implement multiple selection
문제 :  
In this example, each Letter has an isSelected prop and an onToggle handler that marks it as selected.  
This works, but the state is stored as a selectedId (either null or an ID), so only one letter can get selected at any given time.  
Change the state structure to support multiple selection.  
(How would you structure it? Think about this before writing the code.)  
Each checkbox should become independent from the others.  
Clicking a selected letter should uncheck it.  
Finally, the footer should show the correct number of the selected items.  
  
해결 :  
여러 개의 list를 선택하고 싶기 때문에 배열의 형태를 갖는다.  
이미 배열에 있다면 해당 id를 빼주고, 배열에 없다면 넣어준다.  
```javascript
import { useState } from 'react';
import { letters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [selectedIds, setSelectedIds] = useState([]);

  // TODO: allow multiple selection
  const selectedCount = selectedIds.length;

  function handleToggle(toggledId) {
    if (selectedIds.includes(toggledId)) {
      setSelectedIds(selectedIds.filter(id =>
        id !== toggledId
      ));
    } else {
      setSelectedIds([
        ...selectedIds,
        toggledId
      ]);
    }
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map(letter => (
          <Letter
            key={letter.id}
            letter={letter}
            isSelected={
              selectedIds.includes(letter.id)
            }
            onToggle={handleToggle}
          />
        ))}
        <hr />
        <p>
          <b>
            You selected {selectedCount} letters
          </b>
        </p>
      </ul>
    </>
  );
}
```
<br>

# 3. Sharing State Between Components
두 컴포넌트의 state가 항상 함께 변경해야할 때 state를 공유한다.  
각각의 컴포넌트에서 따로 state를 만들지 않고 공통 부모 컴포넌트에 state를 만들어서 props로 내려준다.  
이런 현상을 **lifting state up**이라고 한다.  

일반적으로 로컬 state를 가진 컴포넌트를 **비제어 컴포넌트**라고 한다.  
반대로 컴포넌트의 중요한 데이터가 외부의 props에 의해서 구동되는 컴포넌트를 **제어 컨포넌트**라고 부른다.  
비제어 컨포넌트는 사용에 용이하지만 유연성이 떨어진다는 단점이 있고, 제어 컨포넌트는 최대한의 유연성을 제공하지만 부모 컴포넌트가 props를 완전히 구성해서 전달해야 한다는 단점이 있다.  
이는 엄격한 기술 용어는 아니지만 컴포넌트가 어떻게 설계되고 어떤 기능을 제공하는지에 대한 설명을 할 때 용이하다.  
<br>

> ### A single source of truth for each state
> 우선 single source of truth(SSOT)란 무엇일까?  
> 데이터베이스, 애플리케이션, 프로세스 등의 모든 데이터에 대해 하나의 출처를 사용하는 개념을 의미한다.  
> 이것은 데이터의 정확성, 일관성, 신뢰성을 보장하고, 일관성 있는 의사결정 및 작업 효율성을 높인다는 장점이 있다.  
> 데이터 및 정보의 일관성을 유지하고 보장하기 위해 매우 중요하다.  
>   
> 근데 state는 하나만 만드는게 아니잖아? 라는 생각으로 자세히 글을 읽어보았다.  
> 모든 state를 하나로 묶는 것이 아니라 각각의 state에 따라 SSOT가 만족한다.  
> 컴포넌트 간에 공유하는 state를 복제하는 대신 공통으로 공유하는 부모로 끌어올려서 필요한 자식에게 전달하기 때문에 각 state마다 해당 정보를 소유하는 특정 컴포넌트가 있다는 뜻이다.  
<br>

## Sharing State Between Components Recap (컴포넌트 간에 state 공유하기 요약)
- 두 컴포넌트를 조정하려면 해당 컴포넌트의 state를 공통 부모로 이동한다.
- 그런 다음 공통 부모로부터 props를 통해 정보를 전달한다.
- 마지막으로 이벤트 핸들러를 전달하여 자식이 부모의 state를 변경할 수 있도록 한다.
- 컴포넌트를 (props에 의해) “제어”할 지 (state에 의해) “비제어”할지 고려해보는 것은 유용하.
<br>

## Sharing State Between Components Try out some challenges (컴포넌트 간에 state 공유하기 도전 과제)
### Q1. Synced inputs
문제 :  
These two inputs are independent.  
Make them stay in sync: editing one input should update the other input with the same text, and vice versa.  
  
풀이 :  
자식 컴포넌트인 ```Input```에 있던 state를 부모 컴포넌트인 ```SyncedInputs```로 올려서 동기화 한다.  
```javascript
import { useState } from 'react';

export default function SyncedInputs() {
  const [text, setText] = useState('');

  const handleChangeText = (e) => {
    setText(e.target.value);
  }

  return (
    <>
      <Input label="First input" text={text} onChangeText={handleChangeText}/>
      <Input label="Second input" text={text} onChangeText={handleChangeText}/>
    </>
  );
}

function Input({ label, text, onChangeText }) {
  // const [text, setText] = useState('');
  
  // function handleChange(e) {
  //   setText(e.target.value);
  // }

  return (
    <label>
      {label}
      {' '}
      <input
        value={text}
        onChange={onChangeText}
      />
    </label>
  );
}
```

### Q2. Filtering a list
문제 :  
In this example, the ```SearchBar``` has its own ```query``` state that controls the text input.  
Its parent ```FilterableList``` component displays a ```List``` of items, but it doesn’t take the search ```query``` into account.  
Use the ```filterItems(foods, query)``` function to filter the list according to the search query.  
To test your changes, verify that typing “s” into the input filters down the list to “Sushi”, “Shish kebab”, and “Dim sum”.  
Note that ```filterItems``` is already implemented and imported so you don’t need to write it yourself!  
  
풀이 :  
```SearchBar```에 있는 ```query``` state를 부모 컴포넌트인 ```FilterableList```로 옮겨서 props로 내려주어서 제어한다.  
```javascript
import { useState } from 'react';
import { foods, filterItems } from './data.js';

export default function FilterableList() {
  const [query, setQuery] = useState('');

  function handleChange(e) {
    setQuery(e.target.value);
  }
  
  return (
    <>
      <SearchBar query={query} onChange={handleChange}/>
      <hr />
      <List items={foods} query={query}/>
    </>
  );
}

function SearchBar({query, onChange}) {
  return (
    <label>
      Search:{' '}
      <input
        value={query}
        onChange={onChange}
      />
    </label>
  );
}

function List({ items, query }) {
  return (
    <table>
      <tbody>
        {filterItems(foods, query).map(food => ( 
          <tr key={food.id}>
            <td>{food.name}</td>
            <td>{food.description}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```
<br>


# 4. Preserving and Resetting State
컴포넌트를 리렌더링할 때, react는 트리의 어떤 부분을 유지하고 업데이트해야할 지, 어떤 부분을 버리거나 맨 처음부터 다시 만들지 결정한다.  
이런 동작은 자동으로 이루어지고, 기본적으로 이전에 렌더링한 tree와 "일치"하는 부분을 유지한다.  
하지만, 이런 기본 동작을 원하지 않는다면, 기본 동작을 무시하고 state를 강제로 초기화 하기 위해 "key"를 사용한다.  
key를 사용한다는 것은 새 데이터로 처음부터 다시 만들어야 하는 컴포넌트라고 간주한다는 뜻과 같다.  


## How React “sees” component structures
브라우저는 UI를 모델링하기 위해 tree구조를 사용한다.  
React는 컴포넌트로부터 반환되는 JSX를 통해 React DOM을 만들고, React DOM은 해당 UI 트리와 일치하도록, 브라우저 DOM 요소를 업데이트 한다.  
react는 *UI tree 구조의 위치를 기준으로 어떤 state가 어떤 컴포넌트에 속하는지 추척*하기 때문에, 우리는 **state를 언제 보존하고 언제 초기화할 지 제어할 수 있다.**  
![리액트트리구조](https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_dom_tree.png&w=1920&q=75)

<br>  
  
state는 컴포넌트 사이에서 **독립적**으로 존재하고 **State는 tree의 위치에 연결되어 있다.**  
컴포넌트에 state를 지정할 때, state는 컴포넌트 안에 지정된 것 같지만, 사실 React 안에 있다.(선반 위에 있는 것 처럼)  
React는 컴포넌트가 UI트리에 있는 위치에 따라 각 state를 올바른 컴포넌트와 연결한다.  
동일한 컴포넌트를 나란히 선언하더라도 **각 트리에서 고유한 위치에서 렌더링되기 때문에 완전히 독립적인 sate를 갖는다.**  
```javascript
import { useState } from 'react';

export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```
<br>

위 코드의 UI구조를 살펴보면 아래의 그림과 같다. counter는 각 트리에서 고유한 위치에 렌더링되기 때문에 두 개의 개별 카운터이다.  
각 컴포넌트는 독립된 state를 갖는다.  
<br>

<img src="https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.png&w=828&q=75" width="500" height="300">
<br><br><br>

이번엔 다른 예시를 보자. 2번째 컴포넌트가 체크박스를 선택하면 사라지고 체크를 풀면 다시 생기는 코드이다.  
```javascript
import { useState } from 'react';

export default function App() {
  const [showB, setShowB] = useState(true);
  return (
    <div>
      <Counter />
      {showB && <Counter />} 
      <label>
        <input
          type="checkbox"
          checked={showB}
          onChange={e => {
            setShowB(e.target.checked)
          }}
        />
        Render the second counter
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```
<br>

두 번째 counter 렌더링을 중지하는 순간 React가 컴포넌트를 제거하면 그 state가 사라지기 때문에 state가 완전히 사라지고 다시 누르면 reset 되는 것이다.  
React는 UI tree의 위치(같은 위치)에서 렌더링하는 동안 컴포넌트의 state를 유지한다.  
<br>

<img src="https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_remove_component.png&w=1080&q=70" width="500" height="300">
<br><br>

## state를 유지할까? 초기화할까?
위의 예시처럼 **동일한 위치의 동일한 컴포넌트는 state를 유지**한다.  
다른 컴포넌트지만 UI 구조가 동일한 컴포넌트가 같은 위치에 있다면 React는 같은 컴포넌트라고 인지한다.  
React에서는 JSX 마크업이 중요한게 아니라 **UI 트리 구조의 위치가 중요**하다.  

하지만, **동일한 위치의 다른 컴포넌트는 state를 초기화**한다.  
같은 위치에 서로 다른 컴포넌트를 전환한다면 state가 초기화된다.  
아래의 예시처럼 같은 컴포넌트를 부르지만 감싸는 태그가 다르다면 UI 트리 구조가 달라지므로 다른 컴포넌트라고 인지해서 state를 초기한다.  
렌더링 사이에 state를 유지하려면 tree 구조가 "일치"해야한다.  
```javascript
return (
  {{isFancy ? (
    <div>
      <Counter isFancy={true} /> 
    </div>
  ) : (
    <section>
      <Counter isFancy={false} />
    </section>
  )}}
)
```
<img src="https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=1920&q=75" width="700" height="300">
<br><br><br>
  
> ### 컴포넌트 안에 컴포넌트 중첩 정의 안돼!
> 상위 컴포넌트를 렌더링할 때마다 중첩된 하위 컴포넌트가 생성되어 계속 state가 초기화된다.  
> 이는 많은 버그를 발생시키고 성능을 떨어트리는 중요한 문제가 될 수 있다.  
> 항상 컴포넌트 함수는 최상위 수준에서 선언하고 중첩은 하지 않는 것으로 하자!  
<br>

## 동일한 위치에서 state reset 하기
같은 위치에 있는 컴포넌트를 사용자의 선택에 따라 state를 따로 쓰고 싶다면 (예. 채팅 앱) 두 가지 방법이 있다.  
1. **컴포넌트를 다른 위치에 렌더링하기**  
   이 방법은 각 컴포넌트의 state가 DOM에서 제거될 때마다 소멸되기 때문에 틀릭할 때마다 초기화된다.
   같은 위치에 몇 개의 컴포넌트만 렌더링될 때 사용한다. 많아지면 번거롭다.
   아래의 코드처럼 하나의 위치에서 렌더링하는 것이 아니라 다른 위치에서 렌더링한다면, 2개의 가지가 만들어진 것과 동일하다.  
   ```javascript
   import { useState } from 'react'; 
   export default function Scoreboard() {
      const [isPlayerA, setIsPlayerA] = useState(true);
      return (
        <div>
          {isPlayerA &&
            <Counter person="Taylor" />
          }
          {!isPlayerA &&
            <Counter person="Sarah" />
          }
          <button onClick={() => {
            setIsPlayerA(!isPlayerA);
          }}>
            Next player!
          </button>
        </div>
      );
   }
   ```
2. **각 컴포넌트에 key를 부여하여 명시적으로 구분하기**  
   key는 목록을 렌더링할 때만 사용하는 것이 아니다.  
   key를 지정하면 key 자리를 위치의 일부로써 사용한다. => 다른 key를 사용하면 같은 위치에서 렌더링하더라도 다른 컴포넌트  
   key는 전역으로 고유한 것이 아니라, 부모 내의 위치에서만 구분한다.
   ```javascript
   import { useState } from 'react';
   export default function Scoreboard() {
      const [isPlayerA, setIsPlayerA] = useState(true);
      return (
        <div>
          {isPlayerA ? (
            <Counter key="Taylor" person="Taylor" />
          ) : (
            <Counter key="Sarah" person="Sarah" />
          )}
          <button onClick={() => {
            setIsPlayerA(!isPlayerA);
          }}>
            Next player!
          </button>
        </div>
      );
   }
   ```
<br>

## Preserving and Resetting State Recap (State 보존하고 재설정하기 요약)
- React는 동일한 컴포넌트가 동일한 위치에서 렌더링되는 한 state를 유지한다.  
- state는 JSX 태그에 보관되지 않는다. JSX를 넣은 트리 위치와 연관되어 있다.  
- 하위 트리에 다른 key를 지정하여 강제로 state를 재설정할 수 있다.
- 컴포넌트 정의를 중첩하지 말자. 실수로 state가 초기화될 수 있다.
<br>

## Preserving and Resetting State Try out some challenges (State 보존하고 재설정하기 도전 과제)
### Q1. Fix disappearing input text
문제 :  
This example shows a message when you press the button.  
However, pressing the button also accidentally resets the input.  
Why does this happen?  
Fix it so that pressing the button does not reset the input text.  
  
풀이 :  
showHint의 값에 따라 ```<p>```에 있는 값이 나왔다가 사라지므로 ```&&``` 연산자를 사용해서 동일한 컴포넌트 위치를 유지한다.  
버튼 또한 showHint 값에 따라 onChange와 표출 문구가 바뀌기 때문에 삼항연산자를 사용하여 동일한 컴포넌트의 위치를 유지해준다.  
```javascript
import { useState } from "react";

export default function App() {
  const [showHint, setShowHint] = useState(false);
  return (
    <div>
      {showHint && (
        <p>
          <i>Hint: Your favorite city?</i>
        </p>
      )}
      <Form />
      {showHint ? (
        <button
          onClick={() => {
            setShowHint(false);
          }}
        >
          Hide hint
        </button>
      ) : (
        <button
          onClick={() => {
            setShowHint(true);
          }}
        >
          Show hint
        </button>
      )}
    </div>
  );
}

function Form() {
  const [text, setText] = useState("");
  return <textarea value={text} onChange={(e) => setText(e.target.value)} />;
}
```

### Q2. Swap two form fields
문제 :  
This form lets you enter first and last name.  
It also has a checkbox controlling which field goes first.  
When you tick the checkbox, the “Last name” field will appear before the “First name” field.  
It almost works, but there is a bug.  
If you fill in the “First name” input and tick the checkbox, the text will stay in the first input (which is now “Last name”).  
Fix it so that the input text also moves when you reverse the order.  
  
풀이 :  
똑같이 생긴 UI 구조를 가지고 있기 때문에 구분이 안된 것!  
각 Form에 key를 부여해서 일치시킨다.  
```javascript
import { useState } from 'react';

export default function App() {
  const [reverse, setReverse] = useState(false);
  let checkbox = (
    <label>
      <input
        type="checkbox"
        checked={reverse}
        onChange={e => setReverse(e.target.checked)}
      />
      Reverse order
    </label>
  );
  if (reverse) {
    return (
      <>
        <Field label="Last name" key="last"/> 
        <Field label="First name" key="first"/>
        {checkbox}
      </>
    );
  } else {
    return (
      <>
        <Field label="First name" key="first"/> 
        <Field label="Last name" key="last"/>
        {checkbox}
      </>
    );
      }
}

function Field({ label }) {
  const [text, setText] = useState('');
  return (
    <label>
      {label}:{' '}
      <input
        type="text"
        value={text}
        placeholder={label}
        onChange={e => setText(e.target.value)}
      />
    </label>
  );
}
```

### Q3. Reset a detail form
문제 :  
This is an editable contact list.  
You can edit the selected contact’s details and then either press “Save” to update it, or “Reset” to undo your changes.  
When you select a different contact (for example, Alice), the state updates but the form keeps showing the previous contact’s details.  
Fix it so that the form gets reset when the selected contact changes.  
  
풀이 :  
```EditContact``` 컴포넌트에 key를 부여하여 가계부 정보에 따라 변경되도록 하자.  
```javascript
import { useState } from 'react';
import ContactList from './ContactList.js';
import EditContact from './EditContact.js';

export default function ContactManager() {
  const [
    contacts,
    setContacts
  ] = useState(initialContacts);
  const [
    selectedId,
    setSelectedId
  ] = useState(0);
  const selectedContact = contacts.find(c =>
    c.id === selectedId
  );

  function handleSave(updatedData) {
    const nextContacts = contacts.map(c => {
      if (c.id === updatedData.id) {
        return updatedData;
      } else {
        return c;
      }
    });
    setContacts(nextContacts);
  }

  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={selectedId}
        onSelect={id => setSelectedId(id)}
      />
      <hr />
      <EditContact
        key={selectedId}
        initialData={selectedContact}
        onSave={handleSave}
      />
    </div>
  )
}

const initialContacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

### Q4. Clear an image while it’s loading
문제 :  
When you press “Next”, the browser starts loading the next image.  
However, because it’s displayed in the same <img> tag, by default you would still see the previous image until the next one loads.  
This may be undesirable if it’s important for the text to always match the image.  
Change it so that the moment you press “Next”, the previous image immediately clears.  
  
풀이 :  
```img```태그에 key를 부여하여 바로 반응하게 만들었다.  
```javascript
import { useState } from 'react';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const hasNext = index < images.length - 1;

  function handleClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  let image = images[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h3>
        Image {index + 1} of {images.length}
      </h3>
      <img src={image.src} key={image.src}/>
      <p>
        {image.place}
      </p>
    </>
  );
}

let images = [{
  place: 'Penang, Malaysia',
  src: 'https://i.imgur.com/FJeJR8M.jpg'
}, {
  place: 'Lisbon, Portugal',
  src: 'https://i.imgur.com/dB2LRbj.jpg'
}, {
  place: 'Bilbao, Spain',
  src: 'https://i.imgur.com/z08o2TS.jpg'
}, {
  place: 'Valparaíso, Chile',
  src: 'https://i.imgur.com/Y3utgTi.jpg'
}, {
  place: 'Schwyz, Switzerland',
  src: 'https://i.imgur.com/JBbMpWY.jpg'
}, {
  place: 'Prague, Czechia',
  src: 'https://i.imgur.com/QwUKKmF.jpg'
}, {
  place: 'Ljubljana, Slovenia',
  src: 'https://i.imgur.com/3aIiwfm.jpg'
}];
```

### Q5. Fix misplaced state in the list
문제 :  
In this list, each Contact has state that determines whether “Show email” has been pressed for it.  
Press “Show email” for Alice, and then tick the “Show in reverse order” checkbox.  
You will notice that it’s Taylor’s email that is expanded now, but Alice’s—which has moved to the bottom—appears collapsed.  
Fix it so that the expanded state is associated with each contact, regardless of the chosen ordering.  
  
풀이 :  
key를 index로 줬기 때문에 같이 움직이지 않은 것이다. id로 부여하면 같이 움직인다.  
```javascript
import { useState } from "react";
import Contact from "./Contact.js";

export default function ContactList() {
  const [reverse, setReverse] = useState(false);

  const displayedContacts = [...contacts];
  if (reverse) {
    displayedContacts.reverse();
  }

  return (
    <>
      <label>
        <input
          type="checkbox"
          value={reverse}
          onChange={(e) => {
            setReverse(e.target.checked);
          }}
        />{" "}
        Show in reverse order
      </label>
      <ul>
        {displayedContacts.map((contact) => (
          <li key={contact.id}>
            <Contact contact={contact} />
          </li>
        ))}
      </ul>
    </>
  );
}

const contacts = [
  { id: 0, name: "Alice", email: "alice@mail.com" },
  { id: 1, name: "Bob", email: "bob@mail.com" },
  { id: 2, name: "Taylor", email: "taylor@mail.com" }
];
```
<br>


# 5. Extracting State Logic into a Reducer
state 업데이트가 여러 이벤트 핸들러에 분산되어 있는 컴포넌트는 과부하에 걸릴 수 있다.  
이 때, 모든 state logic을 reducer라는 단일 함수로 통해 state 업데이트 logic을 통합할 수 있다.  

## Reducer가 뭔데?
Reducer은 간단히 말하자면 ```useState```를 대체할 수 있는 state를 관리하고 업데이트할 수 있는 hook이다.  
이벤트 핸들러를 사용자의 *action* 으로 지정하고, reducer에서 각 *action* 에 대한 응답으로 어떻게 업데이트 되는지 지정한다.  
```useState```와 ```useReducer```의 차이는 reducer 사용방법에 대해서 설명한 후에 다시 이야기 해보자.  
<br>
  
## useReducer 사용 방법
우선 reducer은 state를 사용하는 파일에서 만들어도 되지만, reducer만의 파일을 만들어서 정의하기도 한다.  
개인적으로 reducer만의 파일을 만드는 것을 선호하는 편!(왜? state 로직을 한눈에 파악하기에도 편하고 더 간결해보이기 때문)  

### Step 1. reducer 함수 작성
reducer는 함수로 작성한다. 즉, 순수성을 만족해야 한다는 것이다.  
reducer 함수에는 2가지 인자(**state**와 **action**)를 설정한다.  
state : 이전 state 변수를 담고 있다.  
action : type과 payload를 가지고 있으며, 이를 이용해서 state를 setting한다.  

```javascript
// stateReducer.js
export default function stateReducer(state, action) { 
  switch (action.type) {  // action의 type에 따라서 setting 하는 함수를 다르게 한다.
    case "case1" : {      // 각 case 별로 state를 세팅해서 return 해준다.
      // state 변경 로직 넣고
      return "state 변경된 값 반환하고!"        
    }
  }
}
```

### Step2. reducer 함수 적용
```useState```를 통해 setting 했던 state에 reducer을 적용한다.  
reducer은 ```useState```처럼 ```useReducer```을 불러야한다.  
차이점은 state 초깃값 뿐만아니라 Step1 에서 만든 reducer 함수까지 인자로 사용한다는 것이다.  

```javascript
// App.js
import { useReducer } from 'react';            // useReducer 호출
import stateReducer from "./stateReducer.js";  // Step 1 에서 만든 reducer function 호출

export default function Main() {
  const [state, dispatch] = useReducer(stateReducer, initialState);  // reducer함수와 state 초깃값을 넣어준다.
  // state는 함수의 초깃값을 받고, dispatch는 reducer function의 action으로 값을 넘겨주는 함수이다.

  function handleState() {
    dispatch({          // action이 해당 객체를 받는다.
      type: "case1",    // 이 type을 기준으로 state를 setting 한다.
      id: 1234,         // 
      text: "text"
    });
  }
}
```

### Immer 라이브러리 사용 방법
reducer또한 Immer 라이브러리를 사용하여 더 간단하게 사용할 수 있다.  
```javascript
// stateReducer.js
export default function stateReducer(draft, action) { 
  switch (action.type) {
    case "case1" : {
      // state 변경 로직 넣고
      // draft자체를 변경시킴으로써 Immer 라이브러리에 영향을 받는다.
      break;
    }
  }
}
```

```javascript
// App.js
import { useImmerReducer } from 'use-immer';
import stateReducer from "./stateReducer.js";

const [tasks, dispatch] = useImmerReducer(stateReducer, initialState);  // 나머지는 동일하다.
function handleState() {
  dispatch({         
    type: "case1",   
    id: 1234, 
    text: "text"
  });
}
```
<br>

## useState vs useReducer
|기준|useState|useReducer|
|--|----|----|
|코드 크기| 미리 작성하는 코드가 적다. | 미리 작성하는 코드는 많지만, 많은 이벤트 핸들러가 비슷한 방식으로 업데이트할 때 코드를 줄이는데 도움을 준다. |
|가독성| 간단한 state 업데이트의 경우 가독성이 좋다. | 복잡해지는 경우, 업데이트 로직의 구동 방법과 어떤 일이 벌어지는지에 대해 깔끔하게 분리할 수 있다. |
|디버깅| 버그 이유 찾기 어렵다. | reducer에 ```console.log```를 추가함으로써 확인이 가능하지만 useState보다 더 많은 step을 거쳐야 한다. |
|테스팅| 테스트 하기가 어렵다. | 순수 함수이므로, 분리하거나 별개로 테스트할 수 있다. |
<br>

### useReducer 사용하는 경우
1. 일부 컴포넌트에서 잘못된 state 업데이트되어 버기가 자주 발생하는 경우
2. 컴포넌트에서 관리하는 state가 많아져서 구조가 복잡해지는 경우
3. setter함수가 너무 많아졌을 경우
4. 관리할 상태가 여러개이고, 서로가 의존하고 있으며, 상태를 조작할 동작이 여러개일 경우
<br>

## Extracting State Logic into a Reducer Recap (Reducer을 통해 state logic 추출하기 요약)
- useSate에서 useReducer로 변환하려면:
  1. 이벤트 핸들러에서 action을 전달한다.
  2. 주어진 state와 action에 대해 다음 state를 반환하는 reducer 함수를 작성한다.
  3. useState를 useReducer로 바꾼다.
- reducer를 사용하면 코드를 조금 더 작성해야 하지만 디버깅과 테스트에 도움이 된다.
- reducer는 반드시 순수해야 한다.
- 각 action은 단일 사용자 상호작용을 설명해야 한다.
- 변이 스타일로 reducer를 작성하려면 Immer를 사용하.
<br>

## Extracting State Logic into a Reducer Try out some challenges (Reducer을 통해 state logic 추출하기 도전 과제)
### Q1. Dispatch actions from event handlers
문제 :  
Currently, the event handlers in ```ContactList.js``` and ```Chat.js``` have ```// TODO``` comments.  
This is why typing into the input doesn’t work, and clicking on the buttons doesn’t change the selected recipient.  
Replace these two ```// TODO```s with the code to ```dispatch``` the corresponding actions.  
To see the expected shape and the type of the actions, check the reducer in ```messengerReducer.js```.  
The reducer is already written so you won’t need to change it.  
You only need to dispatch the actions in ```ContactList.js``` and ```Chat.js```.  
  
풀이 :  
```// TODO``` 주석 위치에 dispatch를 사용하여 state 변경을 했다.  
```javascript
// Chat.js
import { useState } from "react";

export default function Chat({ contact, message, dispatch }) {
  return (
    <section className="chat">
      <textarea
        value={message}
        placeholder={"Chat to " + contact.name}
        onChange={(e) => {
          // TODO: dispatch edited_message
          // (Read the input value from e.target.value)
          dispatch({
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button>Send to {contact.email}</button>
    </section>
  );
}
```
```javascript
// ContactList.js
export default function ContactList({ contacts, selectedId, dispatch }) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                // TODO: dispatch changed_selection
                dispatch({
                  type: "changed_selection",
                  contactId: contact.id
                });
              }}
            >
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

### Q2. Clear the input on sending a message
문제 :  
Currently, pressing “Send” doesn’t do anything. Add an event handler to the “Send” button that will:  
1. Show an alert with the recipient’s email and the message.  
2. Clear the message input.
<br>
  
풀이 :  
Q1에서 ```Chat.js```와 ```messengerReducer.js``` 파일을 수정한 것이다.  
button에 이벤트 핸들러를 만들어서 적용했고 reducer에 메시지를 보낸 경우를 추가했다.    
현재 내용에 대한 정보를 담긴 alert를 띄워주고 dispatch를 사용해서 message 내용 reset 했다.  
```javascript
// Chat.js
import { useState } from "react";

export default function Chat({ contact, message, dispatch }) {
  const handleButton = () => {
    alert(`Sending "${message}" to ${contact.name}@mail.com`);
    dispatch({
      type: "edited_message",
      message: ''
    });
  }

  return (
    <section className="chat">
      <textarea
        value={message}
        placeholder={"Chat to " + contact.name}
        onChange={(e) => {
          dispatch({
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button onClick={handleButton}>Send to {contact.email}</button>
    </section>
  );
}
```
```javascript
// messengerReducer.js
export const initialState = {
  selectedId: 0,
  message: 'Hello',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    case 'send_message': {
      return {
        ...state,
        message: '',
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

### Q3. Restore input values when switching between tabs
문제 :  
In this example, switching between different recipients always clears the text input:  
```javascript
case 'changed_selection': {
  return {
    ...state,
    selectedId: action.contactId,
    message: '' // Clears the input
  };
```
This is because you don’t want to share a single message draft between several recipients.  
But it would be better if your app “remembered” a draft for each contact separately, restoring them when you switch contacts.  
Your task is to change the way the state is structured so that you remember a separate message draft per contact.  
You would need to make a few changes to the reducer, the initial state, and the components.  
  
풀이 :  
 reducer의 message를 객체형태로 전환하여 각 인물에 대한 멘트를 저장한다.   
 객체 형태이기 때문에 제대로 된 복사를 위해 모든 action을 변경해준다.   
 마지막으로 ```App.js```에서 state를 받는 부분을 수정하면 끝!  
```javascript
// messengerReducer.js
export const initialState = {
  selectedId: 0,
  messages: {
    0: 'hi, Taylor',
    1: 'hi, Alice',
    2: 'hi, Bob'
  },
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
      };
    }
    case 'edited_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId] : action.message
        },
      };
    }
    case 'sent_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId] : ''
        },
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```
```javascript
// App.js
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.messages[state.selectedId];   // state에 맞춰서 수정
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

### Q4. Implement ```useReducer``` from scratch
문제 :  
In the earlier examples, you imported the ```useReducer``` Hook from React.  
This time, you will implement the ```useReducer``` Hook itself! Here is a stub to get you started.  
It shouldn’t take more than 10 lines of code.  
To test your changes, try typing into the input or select a contact.  
  
풀이 :  
```javascript
import { useState } from 'react';

export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch (action) {
    setState((s) => reducer(s, action));
  }

  return [state, dispatch];
}
```

<br>


# 6. Passing Data Deeply with Context
일반적으로 부모 컴포넌트에서 자식 컴포넌트로 props를 통해 정보를 전달한다.  
일부 props를 여러 컴포넌트에 전달하거나 여러 컴포넌트가 동일한 props가 필요한 경우, context를 사용한다.  
context를 사용하면, 부모 컴포넌트가 props를 사용하지 않아도 하위 tree의 모든 컴포넌트가 그 data를 사용할 수 있다.  

## props의 문제점
tree 깊숙히 전달해야 하거나 많은 컴포넌트에 동일한 props가 필요한 경우, props 전달이 길게 늘어지고 불편해진다.  
이 때, 필요한 데이터를 가지고 있는 부모 컴포넌트가 멀리 떨어져 있다면, **prop drilling**이 일어난다.  
<p align="center"><img src="https://github.com/Danee12/JS-REACT-study/assets/70254335/5566e959-4b0c-427d-b406-2919a36c94f4" width="600" height="300"></p>
<br><br>

## Context란?
Context는 간단히 말해서 props 전달의 대안이다. 컴포넌트들이 데이터(state)를 더 쉽게 공유할 수 있도록 해준다.  
context는 자주 업데이트할 필요가 없는 데이터로 설정해야 한다.  
전체적인 상태 관리를 위해 만들어진 시스템이 아니라, 데이터를 쉽게 사용하기 위해 만들어졌기 때문이다.  
context는 컴포넌트를 위한 전역 변수와 같다고 생각하자.  
  
Context를 사용하면 아래의 그림처럼 상위 컴포넌트가 그 아래 전체 트리에 데이터를 제공한다.  
<p align="center"><img src="https://github.com/Danee12/JS-REACT-study/assets/70254335/6dfd2d49-1875-4c14-ab57-8f081f3b5dcd" width="600" height="300"></p>
<br><br>

Context를 제공하는 컴포넌트와 Context를 사용하는 컴포넌트 사이에 원하는 만큼의 컴포넌트를 삽입할 수 있다.  
Context를 사용하면 “주변 환경에 적응”하고 렌더링되는 위치(context)에 따라 다르게 표시되는 컴포넌트를 작성할 수 있다.  
서로 다른 Context는 서로 재정의하지 않기 때문에, ```createContext()``로 만드는 context는 다른 context와 완전히 분리되어 있다.  
특정 context를 사용하거나 제공하는 컴포넌트를 함께 묶고, 하나의 컴포넌트가 다양한 context를 사용하거나 제공할 수 있다.  
<br>

## Context 사용 방법
### Step 1. context 생성
context는 여러 컴포넌트에서 사용하기 때문에 ```export```는 필수!
```javascript
// levelContext.js
import { createContext } from 'react';

export const LevelContext = createContext(1);    // context는 무조건 export!
```

### Step 2. 데이터가 필요한 컴포넌트에서 해당 context를 사용하기
데이터를 사용하는 컴포넌트에서 ```useContext```와 생성한 context인 ```LevelContext```를 불러온다.  
prop으로 받아오던 level을 삭제하고 context를 사용한다.  
```javascript
// 기존 방식
export default function Heading({ level, children }) {
  // ...
}

// context 적용 방식
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}
```

### Step 3. 데이터를 지정하는 컴포넌트에서 해당 context를 제공하기
context provider로 데이터를 제공하는 컴포넌트 트리를 감싼다.  
컴포넌트는 그 위에 있는 UI 트리에서 가장 가까운 <LevelContext.Provider>의 값을 사용한다.  
```javascript
// 기존의 방식
export default function Section({ children }) {
  return (
    <section className="section">
      {children}
    </section>
  );
}

// context적용 방식
import { LevelContext } from './LevelContext.js';

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```
<br>

## Context 사용 전 고려사항
1. props 전달로 시작하자.  
   수십 개의 props를 수십 개의 컴포넌트에 전달해야 하는 경우가 드물지 않다.   
   props를 사용하여 전달을 하면 어떤 컴포넌트가 어떤 데이터를 사용하는지 매우 명확해 진다.   
2. 컴포넌트를 추출하고 JSX를 children으로 전달하자.  
   props drilling이 계속 일어난다면 일부 컴포넌트를 추출하는 것을 잊었을 수도 있다.  
   데이터 props를 직접 사용하지 않는 시각적 컴포넌트에 props를 내려주는 이런 형태보다는 ```<Layout posts={posts} />```  
   Layout이 children을 prop으로 사용하도록 만들도록 하자. ```<Layout><Posts posts={posts} /></Layout>```  
   데이터를 지정하는 컴포넌트와 데이터를 필요로 하는 컴포넌트 사이의 레이어 수가 줄어든다.   
<br>

위의 2가지 방식이 모두 적합하지 않을 때 context를 사용하자.  
<br>

## Context 예시
1. **테마**  
   앱에서 사용자가 앱의 모양을 변경할 수 있는 경우(예: 다크 모드)  
   -> 앱 상단에 context provider를 배치하고 시각적 모양을 조정해야 하는 컴포넌트에서 context를 사용  
2. **현재 계정**
   많은 컴포넌트에서 현재 로그인한 사용자를 알아야 하는 경우 -> 이 정보를 앱 상단에 context로 넣으면 트리의 어느 곳에서나 편리하게 읽을 수 있다.  
   일부 앱에서는 여러 계정을 동시에 조작 가능 (예: 다른 사용자로 댓글을 남기는 경우)  
   -> UI의 일부를 다른 현재 계정 값으로 중첩된 provider로 감싸는 것이 편리할 수 있다.  
3. **라우팅** 
   대부분의 라우팅 솔루션은 내부적으로 context를 사용하여 현재 경로를 유지 -> 모든 링크가 활성 상태인지 아닌지를 “아는” 방식  
   자체 라우터를 구축하는 경우에도 이러한 방식을 사용할 수 있다.  
4. **state 관리**
   앱이 성장함에 따라 복잡한 state를 가진 상위 컴포넌트와 그 state를 사용하고 싶은 컴포넌트가 멀리 떨어질 수 있다.  
   -> context와 함께 reducer를 사용하여 복잡한 state를 관리하고 번거로움 없이 멀리 떨어진 컴포넌트에 전달하는 방법을 사용한다.
<br>

## Passing Data Deeply with Context Recap (Context를 사용하여 데이터를 깊게 전달하기 요약)
- Context는 컴포넌트가 그 아래 전체 트리에 일부 정보를 제공할 수 있도록 한다.
- context를 전달하려면:
  1. export const MyContext = createContext(defaultValue)를 사용하여 context를 생성하고 내보낸다.
  2. useContext(MyContext) 훅에 전달하여 깊이에 상관없이 모든 하위 컴포넌트에서 읽을 수 있도록 한다.
  3. 자식 컴포넌트를 <MyContext.Provider value={...}>로 감싸서 부모로부터 제공받는다.
- Context는 중간에 있는 모든 컴포넌트를 통과한다.
- Context를 사용하면 “주변 환경에 적응”하는 컴포넌트를 작성할 수 있다.
- context를 사용하기 전에 props를 전달하거나 JSX를 children으로 전달해 보자.
<br>

## Passing Data Deeply with Context Try out some challenges (Context를 사용하여 데이터를 깊게 전달하기 도전 과제)
### Q1. Replace prop drilling with context
문제 :  
In this example, toggling the checkbox changes the ```imageSize``` prop passed to each ```<PlaceImage>```.  
The checkbox state is held in the top-level ```App``` component, but each ```<PlaceImage>``` needs to be aware of it.  
Currently, ```App``` passes ```imageSize``` to ```List```, which passes it to each ```Place```, which passes it to the ```PlaceImage```.  
Remove the ```imageSize``` prop, and instead pass it from the ```App``` component directly to ```PlaceImage```.  
You can declare context in ```Context.js```.
  
풀이 :  
```javascript
import { useContext, useState } from 'react';
import { places } from './data.js';
import { getImageUrl } from './utils.js';
import { ImageSizeContext } from './Context.js';

export default function App() {
  const [isLarge, setIsLarge] = useState(false);
  const imageSize = isLarge ? 150 : 100;

  return (
    <ImageSizeContext.Provider
      value = {imageSize}
    >
      <label>
        <input
          type="checkbox"
          checked={isLarge}
          onChange={e => {
            setIsLarge(e.target.checked);
          }}
        />
        Use large images
      </label>
      <hr />
      <List imageSize={imageSize} />
    </ImageSizeContext.Provider>
  )
}

function List() {
  const listItems = places.map(place =>
    <li key={place.id}>
      <Place
        place={place}
      />
    </li>
  );
  return <ul>{listItems}</ul>;
}

function Place({ place }) {
  return (
    <>
      <PlaceImage
        place={place}
      />
      <p>
        <b>{place.name}</b>
        {': ' + place.description}
      </p>
    </>
  );
}

function PlaceImage({ place }) {
  const imageSize = useContext(ImageSizeContext);
  
  return (
    <img
      src={getImageUrl(place)}
      alt={place.name}
      width={imageSize}
      height={imageSize}
    />
  );
}
```
<br>


# 7. Scaling Up with Reducer and Context
Reducer -> state update logic을 통합  
Context -> 하위 컴포넌트에 정보를 deeply 전달  
reducer와 context를 함께 결합하여 복잡한 화면의 state를 관리할 수 있다.  
복잡한 state를 가진 상위 컴포넌트가 reducer로 state를 관리하고, 하위 tree 깊은 곳에 있는 컴포넌트는 context를 통해 state를 읽는다.  

## reducer와 context를 결합하는 방법
1. Context 생성  
2. state와 dispatch 함수를 context에 넣는다.  
3. tree 안에서 context를 사용한다.  
<br>

context와 reducer을 따로 만들어도 되지만, context와 reducer을 같은 파일에 넣었을 때 포넌트들이 데이터를 어디서 가져오는지가 아닌 무엇을 보여줄 것인지에 집중할 수 있도록 깨끗하게 정리할 수 있기 때문에 같은 파일에 넣는 방법으로 정리한다.  
### Step 1 & Step 2. context & reducer 결합
context와 reducer을 밖에서 사용하기 위해서 모두 export 해준다.  
state와 setting function(dispatch)에 대한 context를 각각 만든다. 이 때, 초기값이 ```null```인 이유는 reducer을 통해 업데이트할 것이기 때문이다.  
context provider 컴포넌트를 생성하여 부모 컴포넌트를 children으로 받게 하자.  
context를 사용할 수 있도록 함수를 ```useContext``` 반환 함수를 만들자. -> 이 때 만든 ```useTasks```와 ```useTasksDispatch``` 함수는 커스텀 훅이다.  
```javascript
import { createContext, useContext, useReducer } from 'react';

const TasksContext = createContext(null);            // state에 대한 context
const TasksDispatchContext = createContext(null);    // setting function에 대한 context

export function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        {children}
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}

export function useTasks() {
  return useContext(TasksContext);
}

export function useTasksDispatch() {
  return useContext(TasksDispatchContext);
}
```

## Scaling Up with Reducer and Context Recap (Reducer와 Context로 확대하기 요약)
- Reducer와 context를 결합해서 컴포넌트가 상위 state를 읽고 수정할 수 있도록 할 수 있다.
- State와 dispatch 함수를 자식 컴포넌트들에 제공하는 방법
  1. 두 개의 context를 만든다. (각각 state와 dispatch 함수를 위한 것).
  2. 하위 컴포넌트들에서 필요한 context를 사용한다.
  3. 하위 컴포넌트들에서 필요한 context를 사용한다.
- 더 나아가 하나의 파일로 합쳐서 컴포넌트들을 정리할 수 있다.
  + Context를 제공하는 TasksProvider 같은 컴포넌트를 내보낼 수 있다.
  + 바로 사용할 수 있도록 useTasks와 useTasksDispatch 같은 사용자 Hook을 내보낼 수 있다.
- context-reducer 조합을 앱에 여러 개 만들 수 있다.
