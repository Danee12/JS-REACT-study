App이 커질수록 state를 구성하는 방법과 컴포넌트 간에 데이트가 흐르는 방법을 의도적으로 만들어야 한다.  
3장에서는 state를 구조적으로 잘 짜는 방법, state 업데이트 로직을 유지 관리하는 방법, 동떨어져 있는 컴포넌트 사이에 state를 공유하는 방법에 대해 배울 것이다.

# 1. Reacting to input with state
React는 코드에서 직접 UI를 수정하는 것이 아니라, state 별로 다양하게 시각적으로 표현하고자 하는 UI를 구현하여, input에 따라 반응하게 만든다.  
이는 표시할 내용을 선언하면 React가 UI를 업데이트하는 방법을 알아내어 반응한다. 이때 *선언*이라는 키워드에 집중하자.  
state 기반 사고방식으로 상호작용에 접근하는 방식에 대해 배워보자.  
  
## 명령형 vs 선언형 프로그래밍
명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가와 가깝다.  
예시를 먼저 생각해보자. 가족과 함께 외식을 한다고 하면,  
- 명령형 방식 (HOW) : "12번 테이블 자리가 비어있습니다. 나와 우리 가족은 저 자리로 걸어가 앉을 것입니다."  
- 선언형 방식 (WHAT) : "네 명 앉을자리를 부탁해요"
<br>

위의 예시에서 보다시피 명령형은 웨이터가 해야할 일은 **어떻게** 해야할지 하나하나 명령을 하고 있으며, 선언형은 내가 **무엇을** 원하는지 말하고 있다.  
프로그래밍에서도 명령형은 한줄한줄 프로그램이 해야하는 일을 *command* 하는 것이고, 선언형은 메서드, 함수 등을 사용하여 *declare* 하는 것이다.  
이때 선언형 프로그래밍에서 사용하는 함수나 메서드 등은 이미 명령형으로 "어떻게"가 구현된 것들이 추상화 되어 있어야만 가능하다.  
코드로 예시를 살펴보자. 명령형에서는 해당하는 내용을 모두 구현했지만 선언형에서는 ```map()```를 사용하여 구현했다.  
이때, map과 같은 메서드, 함수의 내부 구동 원리는 이해하지 않아도 되며, 가독성이 훨씬 좋아진다는 장점이 있다.  
```javascript
// 배열을 파라미터로 받고 각 요소들의 값에 2를 곱하는 함수

// 명령형
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}

// 선언형
function double (arr) {
  return arr.map((item) => item * 2)
}
```
> 출처 : https://boxfoxs.tistory.com/430
<br>

## UI를 React로 구현하는 방법
### STEP 1. *Identify* your component’s different visual states
사용자에게 표시될 수 있는 UI의 다양한 *상태*를 모두 시각화해야 한다.  
다양한 시각적인 상태에 따른 component를 설계해야 하는데, 이때 storybook 또는 living styleguides라고 불리는 한 페이지에 모든 *상태*를 구현해놓는 페이지를 만들기도 한다.  
  
### STEP 2. *Determine* what triggers those state changes
*상태*가 변경되는 이유는 2가지로 정리할 수 있다. 이 두가지 모두 state 변수를 설정해야 한다.  
- 사람의 입력 : 버튼 클릭, 필드 입력, 링크 이동 등
- 컴퓨터의 입력 : 네트워크에서 응답 도착, 시간 초과, 이미지 로딩 등
<br>

상태가 변경되는 흐름을 시각화하는 과정은 흐름을 파악하는 것 뿐만 아니라 구현하기 전에 버그에 대해 예방할 수 있다.  
종이에 각 상태가 적힌 원을 그리고 각 상태 사이의 변경 사항을 화살표로 그려보자.  
![상태흐름도.png](https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.png&w=1920&q=75)

### STEP 3. *Represent* the state in memory using useState
컴포넌트의 시각적 *상태* 를 ```useState```를 사용하여 표현한다.  
이 과정은 **단순함**이 중요하기 때문에, 가능한 적은 수의 state를 사용한다.  
반드시 필요한 state부터 생성하여 시각적 상태 중 어떤 상태를 표시할지 나타내는 state 변수가 필요하다.  
이 과정에서 처음부터 완벽한 구조가 짜여지는 것은 힘들다. state를 계속 리팩토링하여 최적의 state가 되도록 하는 것도 굉장한 경험이 될 것이다.  

### STEP 4. *Remove* any non-essential state variables
state 변수는 중복과 불필요한 변수는 없어야 한다. 이를 통해 state가 사용자에게 보여주기를 원하는 UI를 나타내지 않는 경우를 방지하고자 한다.  
아래의 질문을 통해 essential state variables만 남기도록 하자.
- 이 state가 모순을 발생시키는가?
- 이미 존재하는 state에 같은 정보가 있는가?
- 다른 state를 뒤집으면 같은 정보가 되는가?
<br>


### STEP 5. *Connect* the event handlers to set the state
<br>

## Reacting to input with state Recap (state를 사용하여 input에 반응하기 요약)
- 선언형 프로그래밍은 UI를 세밀하게 관리(명령형)하지 않고 각 시각적 상태에 대해 UI를 기술하는 것을 의미한다.
- 컴포넌트를 개발할 때
  1. 모든 시각적 상태를 식별하자.
  2. 사람 및 컴퓨터가 상태 변화를 촉발하는 요인을 결정하자.
  3. useState로 상태를 모델링하자.
  4. 버그와 모순을 피하려면 비필수적인 state를 제거하자.
  5. 이벤트 핸들러를 연결하여 state를 설정하자.
<br>

## Reacting to input with state Try out some challenges (state를 사용하여 input에 반응하기 도전과제)
### Q1. Add and remove a CSS class
문제 :  
Make it so that clicking on the picture removes the background--active CSS class from the outer <div>, but adds the picture--active class to the <img>.  
Clicking the background again should restore the original CSS classes.  
Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border.  
Clicking outside the picture highlights the background, but removes the picture border highlight.  
  
풀이 :  
사진을 클릭했을 때 상태를 변경해주기 위한 state 변수를 하나 설정한다.  
배경을 클릭했을 때 false가 되고 사진을 클릭했을 때 true가 되어 설정하도록 하자.  
단, 배경은 사진을 품고 있기 때문에 클릭했을 때 true -> false로 순식간에 바뀐다. ```stopPropagation()```을 사용하여 전파를 막는다.  
state 변수 상태에 따라 className이 변경되기 때문에 맞춰서 수정한다.  
className은 따로 일반변수를 활용할 수도 있지만 한줄로 간단하게 만들 수 있기 때문에 JSX안에서 삼항연산자를 사용했다.  
```javascript
import { useState } from "react";

export default function Picture() {
  const [click, setClick] = useState(false);

  return (
    <div 
      className={click ? "background" : "background background--active"}
      onClick={() => setClick(false)}
    >
      <img
        className={click ? "picture picture--active" : "picture"}
        alt="Rainbow houses in Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
        onClick={(e) => {
          e.stopPropagation();
          setClick(true)
        }}
      />
    </div>
  );
}
```

### Q2. Profile editor
문제 :  
Here is a small form implemented with plain JavaScript and DOM. Play with it to understand its behavior:  
```javascript
function handleFormSubmit(e) {
  e.preventDefault();
  if (editButton.textContent === 'Edit Profile') {
    editButton.textContent = 'Save Profile';
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = 'Edit Profile';
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
}

function handleFirstNameChange() {
  firstNameText.textContent = firstNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function handleLastNameChange() {
  lastNameText.textContent = lastNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
This form switches between two modes: in the editing mode, you see the inputs, and in the viewing mode, you only see the result.  
The button label changes between “Edit” and “Save” depending on the mode you’re in.  
When you change the inputs, the welcome message at the bottom updates in real time.  
Your task is to reimplement it in React in the sandbox below.  
For your convenience, the markup was already converted to JSX, but you’ll need to make it show and hide the inputs like the original does.  
Make sure that it updates the text at the bottom, too!  
  
풀이 :  
먼저 이름을 담는 state와 수정 버튼을 클릭했는지의 상태를 담는 state를 만든다.  
버튼을 눌렀을 때 isEdit의 상태가 바뀌어야 하는데 form은 새로고침을 해주기 때문에 ```preventDefault()```을 사용하여 제한한다.  
isEdit의 상태에 따라 UI가 변경되도록 코드를 수정한다.  
```javascript
import { useState } from "react";

export default function EditProfile() {
  const [name, setName] = useState({ firstName: "Jane", lastName: "Jacobs" });
  const [isEdit, setIsEdit] = useState(false);

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsEdit(!isEdit);
      }}
    >
      <label>
        First name:{" "}
        {isEdit ? (
          <input
            value={name.firstName}
            onChange={(e) => {
              setName({ ...name, firstName: e.target.value });
            }}
          />
        ) : (
          <b>{name.firstName}</b>
        )}
      </label>
      <label>
        Last name:{" "}
        {isEdit ? (
          <input
            value={name.lastName}
            onChange={(e) => {
              setName({ ...name, lastName: e.target.value });
            }}
          />
        ) : (
          <b>{name.lastName}</b>
        )}
      </label>
      <button type="submit">{isEdit ? "Save Profile" : "Edit Profile"}</button>
      <p>
        <i>Hello, {name.firstName + " " + name.lastName}</i>
      </p>
    </form>
  );
}
```

### Q3. Refactor the imperative solution without React
문제 :  
Here is the original sandbox from the previous challenge, written imperatively without React: (2번에 있으니까 안가져옴)  
Imagine React didn’t exist. Can you refactor this code in a way that makes the logic less fragile and more similar to the React version?  
What would it look like if the state was explicit, like in React?  
If you’re struggling to think where to start, the stub below already has most of the structure in place.  
If you start here, fill in the missing logic in the updateDOM function. (Refer to the original code where needed.)  
  
풀이 :  
항상 react로 해오다가 명령형을 사용하니 신기했다.  
```javascript
let firstName = "Jane";
let lastName = "Jacobs";
let isEditing = false;

function handleFormSubmit(e) {
  e.preventDefault();
  setIsEditing(!isEditing);
}

function handleFirstNameChange(e) {
  setFirstName(e.target.value);
}

function handleLastNameChange(e) {
  setLastName(e.target.value);
}

function setFirstName(value) {
  firstName = value;
  updateDOM();
}

function setLastName(value) {
  lastName = value;
  updateDOM();
}

function setIsEditing(value) {
  isEditing = value;
  updateDOM();
}

function updateDOM() {
  if (isEditing) {
    editButton.textContent = "Save Profile";
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = "Edit Profile";
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
  firstNameText.textContent = firstName;
  lastNameText.textContent = lastName;
  helloText.textContent = "Hello " + firstName + " " + lastName + "!";
}

function hide(el) {
  el.style.display = "none";
}

function show(el) {
  el.style.display = "";
}

let form = document.getElementById("form");
let editButton = document.getElementById("editButton");
let firstNameInput = document.getElementById("firstNameInput");
let firstNameText = document.getElementById("firstNameText");
let lastNameInput = document.getElementById("lastNameInput");
let lastNameText = document.getElementById("lastNameText");
let helloText = document.getElementById("helloText");
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
<br>


# 2. Choosing the State Structure
state를 잘 구조화하면 수정과 디버깅이 편해지고 버그를 방지할 수 있다.  
state를 갖고 있는 component를 작성할 때, state 변수를 몇개나 쓸 것인지, 데이터를 어떤 형태로 사용할 것인지 정해야한다.  
이런 점을 고려하면서 state의 원칙을 살펴보자.  

## state 구조화 원칙
1. 연관된 state끼리 그룹화하자.  
   항상 2개 이상의 state가 동시에 변한다면 하나로 통합한다.  
   또한 사용자 정의 필드를 추가하는 것처럼 필요한 state 수가 사용자에 의해 변할 때 하나의 객체 state를 만들어 적용한다.  
2. state에서 모순은 피하자.  
   여러가지 state가 있을 때 서로 모순이 되거나 "불일치"해진다면 에러가 발생할 수 있다.  
3. 불필요한 state는 피하자.  
   렌더링 도중에 props나 기존의 state로 계산할 수 있다면 state로 새로 생성하지 않는다.  
   state 변수로 계산하는 일반 변수는 rendering 도중 자동으로 계산이 된다.  
   props로 받은 변수를 state의 초깃값으로 사용하지 말자. (단, 부모에서 변경될 때 연동이 되고 싶지 않다면 괜찮다.)  
4. state의 중복은 피하자.  
    동일한 데이터가 여러 state 변수 간에 또는 중첩된 객체 내에 중복되면 동기화 state를 유지하기가 어렵다.  
5. 깊게 중첩된 state는 피하자.
   깊게 계층화된 state는 업데이트하기 쉽지 않다. 최대한 "flat"하게 만들어야 한다.
   중첩된 state의 일부를 하위 컴포넌트로 이동하여 state 중첩을 줄일 수도 있다.  
<br>

## Choosing the State Structure Recap (state 구조 선택하기 요약)
- 두 개의 state 변수가 항상 함께 업데이트되는 경우 두 변수를 하나로 병합하는 것이 좋다.
- state 변수를 신중하게 선택하여 ‘불가능한’ state를 만들지 않도록 하자.
- state를 업데이트할 때 실수할 가능성을 줄이는 방식으로 state를 구성하자.
- 동기화 state를 유지할 필요가 없도록 불필요 및 중복 state를 피하자.
- 특별히 업데이트를 막으려는 경우가 아니라면 props를 state에 넣지 않는 것이 좋다.
- 선택과 같은 UI 패턴의 경우 객체 자체 대신 ID 또는 인덱스를 state로 유지한다.
- 깊게 중첩된 state를 업데이트하는 것이 복잡하다면 state를 평평하게 만들어 보자.
<br>

## Choosing the State Structure Try out some challenges (state 구조 선택하기 도전 과제)
### Q1. Fix a component that’s not updating
문제 :  
This Clock component receives two props: color and time.  
When you select a different color in the select box, the Clock component receives a different color prop from its parent component.  
However, for some reason, the displayed color doesn’t update. Why? Fix the problem.  

해결 :  
부모 컴포넌트에서 받아온 props를 새롭게 state 변수로 생성한다면, 색상이 변화하지 않는다.  
받은 props를 그대로 사용하자.  
```javascript
// import { useState } from 'react';

export default function Clock(props) {
  // const [color, setColor] = useState(props.color);
  return (
    <h1 style={{ color: props.color }}>
      {props.time}
    </h1>
  );
}
```

### Q2. Fix a broken packing list
문제 :  
This packing list has a footer that shows how many items are packed, and how many items there are overall.  
It seems to work at first, but it is buggy.  
For example, if you mark an item as packed and then delete it, the counter will not be updated correctly.  
Fix the counter so that it’s always correct.  
  
해결 :  
total과 packed state는 items state로 계산이 가능하기 때문에 items를 사용한다.  
```javascript
import { useState } from "react";
import AddItem from "./AddItem.js";
import PackingList from "./PackingList.js";

let nextId = 3;
const initialItems = [
  { id: 0, title: "Warm socks", packed: true },
  { id: 1, title: "Travel journal", packed: false },
  { id: 2, title: "Watercolors", packed: false }
];

export default function TravelPlan() {
  const [items, setItems] = useState(initialItems);
  // const [total, setTotal] = useState(3);
  // const [packed, setPacked] = useState(1);

  const total = items.length;
  const packed = items.filter((item) => item.packed === true).length;

  function handleAddItem(title) {
    setItems([
      ...items,
      {
        id: nextId++,
        title: title,
        packed: false
      }
    ]);
  }

  function handleChangeItem(nextItem) {
    // if (nextItem.packed) {
    //   setPacked(packed + 1);
    // } else {
    //   setPacked(packed - 1);
    // }
    setItems(
      items.map((item) => {
        if (item.id === nextItem.id) {
          return nextItem;
        } else {
          return item;
        }
      })
    );
  }

  function handleDeleteItem(itemId) {
    setItems(items.filter((item) => item.id !== itemId));
  }

  return (
    <>
      <AddItem onAddItem={handleAddItem} />
      <PackingList
        items={items}
        onChangeItem={handleChangeItem}
        onDeleteItem={handleDeleteItem}
      />
      <hr />
      <b>
        {packed} out of {total} packed!
      </b>
    </>
  );
}

```

### Q3. Fix the disappearing selection
문제 :  
There is a list of letters in state. When you hover or focus a particular letter, it gets highlighted.  
The currently highlighted letter is stored in the highlightedLetter state variable.  
You can “star” and “unstar” individual letters, which updates the letters array in state.  
This code works, but there is a minor UI glitch.  
When you press “Star” or “Unstar”, the highlighting disappears for a moment.  
However, it reappears as soon as you move your pointer or switch to another letter with keyboard.  
Why is this happening? Fix it so that the highlighting doesn’t disappear after the button click.  
  
해결 :  
letter 자체를 담지 말고 id를 담아서 그 위치를 정확하게 잡고 있자.  
```javascript
import { useState } from "react";
import { initialLetters } from "./data.js";
import Letter from "./Letter.js";

export default function MailClient() {
  const [letters, setLetters] = useState(initialLetters);
  const [highlightedId, setHighlightedId] = useState(null);

  function handleHover(letter) {
    setHighlightedId(letter.id);
  }

  function handleStar(starred) {
    setLetters(
      letters.map((letter) => {
        if (letter.id === starred.id) {
          return {
            ...letter,
            isStarred: !letter.isStarred
          };
        } else {
          return letter;
        }
      })
    );
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map((letter) => (
          <Letter
            key={letter.id}
            letter={letter}
            isHighlighted={letter.id === highlightedId}
            onHover={handleHover}
            onToggleStar={handleStar}
          />
        ))}
      </ul>
    </>
  );
}
```

### Q4. Implement multiple selection
문제 :  
In this example, each Letter has an isSelected prop and an onToggle handler that marks it as selected.  
This works, but the state is stored as a selectedId (either null or an ID), so only one letter can get selected at any given time.  
Change the state structure to support multiple selection.  
(How would you structure it? Think about this before writing the code.)  
Each checkbox should become independent from the others.  
Clicking a selected letter should uncheck it.  
Finally, the footer should show the correct number of the selected items.  
  
해결 :  
여러 개의 list를 선택하고 싶기 때문에 배열의 형태를 갖는다.  
이미 배열에 있다면 해당 id를 빼주고, 배열에 없다면 넣어준다.  
```javascript
import { useState } from 'react';
import { letters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [selectedIds, setSelectedIds] = useState([]);

  // TODO: allow multiple selection
  const selectedCount = selectedIds.length;

  function handleToggle(toggledId) {
    if (selectedIds.includes(toggledId)) {
      setSelectedIds(selectedIds.filter(id =>
        id !== toggledId
      ));
    } else {
      setSelectedIds([
        ...selectedIds,
        toggledId
      ]);
    }
  }

  return (
    <>
      <h2>Inbox</h2>
      <ul>
        {letters.map(letter => (
          <Letter
            key={letter.id}
            letter={letter}
            isSelected={
              selectedIds.includes(letter.id)
            }
            onToggle={handleToggle}
          />
        ))}
        <hr />
        <p>
          <b>
            You selected {selectedCount} letters
          </b>
        </p>
      </ul>
    </>
  );
}
```
<br>

# 3. Sharing State Between Components
