App이 커질수록 state를 구성하는 방법과 컴포넌트 간에 데이트가 흐르는 방법을 의도적으로 만들어야 한다.  
3장에서는 state를 구조적으로 잘 짜는 방법, state 업데이트 로직을 유지 관리하는 방법, 동떨어져 있는 컴포넌트 사이에 state를 공유하는 방법에 대해 배울 것이다.

# 1. Reacting to input with state
React는 코드에서 직접 UI를 수정하는 것이 아니라, state 별로 다양하게 시각적으로 표현하고자 하는 UI를 구현하여, input에 따라 반응하게 만든다.  
이는 표시할 내용을 선언하면 React가 UI를 업데이트하는 방법을 알아내어 반응한다. 이때 *선언*이라는 키워드에 집중하자.  
state 기반 사고방식으로 상호작용에 접근하는 방식에 대해 배워보자.  
  
## 명령형 vs 선언형 프로그래밍
명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가와 가깝다.  
예시를 먼저 생각해보자. 가족과 함께 외식을 한다고 하면,  
- 명령형 방식 (HOW) : "12번 테이블 자리가 비어있습니다. 나와 우리 가족은 저 자리로 걸어가 앉을 것입니다."  
- 선언형 방식 (WHAT) : "네 명 앉을자리를 부탁해요"
<br>

위의 예시에서 보다시피 명령형은 웨이터가 해야할 일은 **어떻게** 해야할지 하나하나 명령을 하고 있으며, 선언형은 내가 **무엇을** 원하는지 말하고 있다.  
프로그래밍에서도 명령형은 한줄한줄 프로그램이 해야하는 일을 *command* 하는 것이고, 선언형은 메서드, 함수 등을 사용하여 *declare* 하는 것이다.  
이때 선언형 프로그래밍에서 사용하는 함수나 메서드 등은 이미 명령형으로 "어떻게"가 구현된 것들이 추상화 되어 있어야만 가능하다.  
코드로 예시를 살펴보자. 명령형에서는 해당하는 내용을 모두 구현했지만 선언형에서는 ```map()```를 사용하여 구현했다.  
이때, map과 같은 메서드, 함수의 내부 구동 원리는 이해하지 않아도 되며, 가독성이 훨씬 좋아진다는 장점이 있다.  
```javascript
// 배열을 파라미터로 받고 각 요소들의 값에 2를 곱하는 함수

// 명령형
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}

// 선언형
function double (arr) {
  return arr.map((item) => item * 2)
}
```
> 출처 : https://boxfoxs.tistory.com/430
<br>

## UI를 React로 구현하는 방법
### STEP 1. *Identify* your component’s different visual states
사용자에게 표시될 수 있는 UI의 다양한 *상태*를 모두 시각화해야 한다.  
다양한 시각적인 상태에 따른 component를 설계해야 하는데, 이때 storybook 또는 living styleguides라고 불리는 한 페이지에 모든 *상태*를 구현해놓는 페이지를 만들기도 한다.  
  
### STEP 2. *Determine* what triggers those state changes
*상태*가 변경되는 이유는 2가지로 정리할 수 있다. 이 두가지 모두 state 변수를 설정해야 한다.  
- 사람의 입력 : 버튼 클릭, 필드 입력, 링크 이동 등
- 컴퓨터의 입력 : 네트워크에서 응답 도착, 시간 초과, 이미지 로딩 등
<br>

상태가 변경되는 흐름을 시각화하는 과정은 흐름을 파악하는 것 뿐만 아니라 구현하기 전에 버그에 대해 예방할 수 있다.  
종이에 각 상태가 적힌 원을 그리고 각 상태 사이의 변경 사항을 화살표로 그려보자.  
![상태흐름도.png](https://react-ko.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.png&w=1920&q=75)

### STEP 3. *Represent* the state in memory using useState
컴포넌트의 시각적 *상태* 를 ```useState```를 사용하여 표현한다.  
이 과정은 **단순함**이 중요하기 때문에, 가능한 적은 수의 state를 사용한다.  
반드시 필요한 state부터 생성하여 시각적 상태 중 어떤 상태를 표시할지 나타내는 state 변수가 필요하다.  
이 과정에서 처음부터 완벽한 구조가 짜여지는 것은 힘들다. state를 계속 리팩토링하여 최적의 state가 되도록 하는 것도 굉장한 경험이 될 것이다.  

### STEP 4. *Remove* any non-essential state variables
state 변수는 중복과 불필요한 변수는 없어야 한다. 이를 통해 state가 사용자에게 보여주기를 원하는 UI를 나타내지 않는 경우를 방지하고자 한다.  
아래의 질문을 통해 essential state variables만 남기도록 하자.
- 이 state가 모순을 발생시키는가?
- 이미 존재하는 state에 같은 정보가 있는가?
- 다른 state를 뒤집으면 같은 정보가 되는가?
<br>


### STEP 5. *Connect* the event handlers to set the state
<br>

## Reacting to input with state Recap (state를 사용하여 input에 반응하기 요약)
- 선언형 프로그래밍은 UI를 세밀하게 관리(명령형)하지 않고 각 시각적 상태에 대해 UI를 기술하는 것을 의미한다.
- 컴포넌트를 개발할 때
  1. 모든 시각적 상태를 식별하자.
  2. 사람 및 컴퓨터가 상태 변화를 촉발하는 요인을 결정하자.
  3. useState로 상태를 모델링하자.
  4. 버그와 모순을 피하려면 비필수적인 state를 제거하자.
  5. 이벤트 핸들러를 연결하여 state를 설정하자.
<br>

## Reacting to input with state Try out some challenges (state를 사용하여 input에 반응하기 도전과제)
### Q1. Add and remove a CSS class
문제 :  
Make it so that clicking on the picture removes the background--active CSS class from the outer <div>, but adds the picture--active class to the <img>.  
Clicking the background again should restore the original CSS classes.  
Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border.  
Clicking outside the picture highlights the background, but removes the picture border highlight.  
  
풀이 :  
사진을 클릭했을 때 상태를 변경해주기 위한 state 변수를 하나 설정한다.  
배경을 클릭했을 때 false가 되고 사진을 클릭했을 때 true가 되어 설정하도록 하자.  
단, 배경은 사진을 품고 있기 때문에 클릭했을 때 true -> false로 순식간에 바뀐다. ```stopPropagation()```을 사용하여 전파를 막는다.  
state 변수 상태에 따라 className이 변경되기 때문에 맞춰서 수정한다.  
className은 따로 일반변수를 활용할 수도 있지만 한줄로 간단하게 만들 수 있기 때문에 JSX안에서 삼항연산자를 사용했다.  
```javascript
import { useState } from "react";

export default function Picture() {
  const [click, setClick] = useState(false);

  return (
    <div 
      className={click ? "background" : "background background--active"}
      onClick={() => setClick(false)}
    >
      <img
        className={click ? "picture picture--active" : "picture"}
        alt="Rainbow houses in Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
        onClick={(e) => {
          e.stopPropagation();
          setClick(true)
        }}
      />
    </div>
  );
}
```

### Q2. Profile editor
문제 :  
Here is a small form implemented with plain JavaScript and DOM. Play with it to understand its behavior:  
```javascript
function handleFormSubmit(e) {
  e.preventDefault();
  if (editButton.textContent === 'Edit Profile') {
    editButton.textContent = 'Save Profile';
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = 'Edit Profile';
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
}

function handleFirstNameChange() {
  firstNameText.textContent = firstNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function handleLastNameChange() {
  lastNameText.textContent = lastNameInput.value;
  helloText.textContent = (
    'Hello ' +
    firstNameInput.value + ' ' +
    lastNameInput.value + '!'
  );
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

let form = document.getElementById('form');
let editButton = document.getElementById('editButton');
let firstNameInput = document.getElementById('firstNameInput');
let firstNameText = document.getElementById('firstNameText');
let lastNameInput = document.getElementById('lastNameInput');
let lastNameText = document.getElementById('lastNameText');
let helloText = document.getElementById('helloText');
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
This form switches between two modes: in the editing mode, you see the inputs, and in the viewing mode, you only see the result.  
The button label changes between “Edit” and “Save” depending on the mode you’re in.  
When you change the inputs, the welcome message at the bottom updates in real time.  
Your task is to reimplement it in React in the sandbox below.  
For your convenience, the markup was already converted to JSX, but you’ll need to make it show and hide the inputs like the original does.  
Make sure that it updates the text at the bottom, too!  
  
풀이 :  
먼저 이름을 담는 state와 수정 버튼을 클릭했는지의 상태를 담는 state를 만든다.  
버튼을 눌렀을 때 isEdit의 상태가 바뀌어야 하는데 form은 새로고침을 해주기 때문에 ```preventDefault()```을 사용하여 제한한다.  
isEdit의 상태에 따라 UI가 변경되도록 코드를 수정한다.  
```javascript
import { useState } from "react";

export default function EditProfile() {
  const [name, setName] = useState({ firstName: "Jane", lastName: "Jacobs" });
  const [isEdit, setIsEdit] = useState(false);

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        setIsEdit(!isEdit);
      }}
    >
      <label>
        First name:{" "}
        {isEdit ? (
          <input
            value={name.firstName}
            onChange={(e) => {
              setName({ ...name, firstName: e.target.value });
            }}
          />
        ) : (
          <b>{name.firstName}</b>
        )}
      </label>
      <label>
        Last name:{" "}
        {isEdit ? (
          <input
            value={name.lastName}
            onChange={(e) => {
              setName({ ...name, lastName: e.target.value });
            }}
          />
        ) : (
          <b>{name.lastName}</b>
        )}
      </label>
      <button type="submit">{isEdit ? "Save Profile" : "Edit Profile"}</button>
      <p>
        <i>Hello, {name.firstName + " " + name.lastName}</i>
      </p>
    </form>
  );
}
```

### Q3. Refactor the imperative solution without React
문제 :  
Here is the original sandbox from the previous challenge, written imperatively without React: (2번에 있으니까 안가져옴)  
Imagine React didn’t exist. Can you refactor this code in a way that makes the logic less fragile and more similar to the React version?  
What would it look like if the state was explicit, like in React?  
If you’re struggling to think where to start, the stub below already has most of the structure in place.  
If you start here, fill in the missing logic in the updateDOM function. (Refer to the original code where needed.)  
  
풀이 :  
항상 react로 해오다가 명령형을 사용하니 신기했다.  
```javascript
let firstName = "Jane";
let lastName = "Jacobs";
let isEditing = false;

function handleFormSubmit(e) {
  e.preventDefault();
  setIsEditing(!isEditing);
}

function handleFirstNameChange(e) {
  setFirstName(e.target.value);
}

function handleLastNameChange(e) {
  setLastName(e.target.value);
}

function setFirstName(value) {
  firstName = value;
  updateDOM();
}

function setLastName(value) {
  lastName = value;
  updateDOM();
}

function setIsEditing(value) {
  isEditing = value;
  updateDOM();
}

function updateDOM() {
  if (isEditing) {
    editButton.textContent = "Save Profile";
    hide(firstNameText);
    hide(lastNameText);
    show(firstNameInput);
    show(lastNameInput);
  } else {
    editButton.textContent = "Edit Profile";
    hide(firstNameInput);
    hide(lastNameInput);
    show(firstNameText);
    show(lastNameText);
  }
  firstNameText.textContent = firstName;
  lastNameText.textContent = lastName;
  helloText.textContent = "Hello " + firstName + " " + lastName + "!";
}

function hide(el) {
  el.style.display = "none";
}

function show(el) {
  el.style.display = "";
}

let form = document.getElementById("form");
let editButton = document.getElementById("editButton");
let firstNameInput = document.getElementById("firstNameInput");
let firstNameText = document.getElementById("firstNameText");
let lastNameInput = document.getElementById("lastNameInput");
let lastNameText = document.getElementById("lastNameText");
let helloText = document.getElementById("helloText");
form.onsubmit = handleFormSubmit;
firstNameInput.oninput = handleFirstNameChange;
lastNameInput.oninput = handleLastNameChange;
```
<br>


# 2. Choosing the State Structure
